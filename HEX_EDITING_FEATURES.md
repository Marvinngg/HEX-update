# HEX è¯­éŸ³è¯†åˆ«ç¼–è¾‘åŠŸèƒ½å®ç°æ–‡æ¡£

---

## ğŸ“– äººè¯ç‰ˆï¼ˆåˆ†äº«ç”¨ï¼‰

### è¿™ä¸ªåº”ç”¨ç°åœ¨èƒ½åšä»€ä¹ˆï¼Ÿ

HEX æ˜¯ä¸€ä¸ª macOS è¯­éŸ³è½¬æ–‡å­—åº”ç”¨ï¼Œæˆ‘ä»¬ç»™å®ƒå¢åŠ äº†ä¸‰ä¸ªè¶…å®ç”¨çš„åŠŸèƒ½ï¼š

#### 1ï¸âƒ£ **å³æ—¶ç¼–è¾‘çª—å£**
å½•éŸ³å®Œæˆåï¼Œä¼šå¼¹å‡ºä¸€ä¸ªå°çª—å£è®©ä½ ç«‹å³ä¿®æ”¹è¯†åˆ«ç»“æœã€‚

- **æ€ä¹ˆç”¨**ï¼šå½•éŸ³ç»“æŸåè‡ªåŠ¨å¼¹çª—ï¼Œç›´æ¥ç¼–è¾‘æ–‡æœ¬
- **å¥½å¤„**ï¼šè¯†åˆ«é”™äº†çš„å†…å®¹å¯ä»¥é©¬ä¸Šæ”¹ï¼Œä¸ç”¨äº‹åå›å¤´æ‰¾
- **æ™ºèƒ½**ï¼šä¿®æ”¹å®Œè‡ªåŠ¨ç²˜è´´åˆ°ä½ åˆšæ‰æ­£åœ¨ç”¨çš„åº”ç”¨é‡Œï¼Œç„¦ç‚¹è‡ªåŠ¨è¿”å›

#### 2ï¸âƒ£ **è‡ªåŠ¨å­¦ä¹ çƒ­è¯**
ä½ ä¿®æ”¹è¿‡çš„è¯æ±‡ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è®°ä½å¹¶å­¦ä¹ ã€‚

- **æ€ä¹ˆç”¨**ï¼šåœ¨ç¼–è¾‘çª—å£ä¿®æ”¹é”™è¯¯è¯†åˆ«çš„è¯ï¼Œç¡®ä¿å‹¾é€‰"è®°ä½æˆ‘çš„ä¿®æ”¹å¹¶å­¦ä¹ "
- **ä¸¾ä¾‹**ï¼šè¯†åˆ«æˆ"å…‹åŠ³å¾·" â†’ ä½ æ”¹æˆ"Claude" â†’ ä¸‹æ¬¡è‡ªåŠ¨è¯†åˆ«æˆ"Claude"
- **åŸç†**ï¼šä¿®æ”¹çš„è¯ä¼šåŒæ—¶åŠ å…¥çƒ­è¯åˆ—è¡¨å’Œå­—è¯æ›¿æ¢è§„åˆ™

#### 3ï¸âƒ£ **çƒ­è¯ç®¡ç†**
å¯ä»¥æ‰‹åŠ¨æ·»åŠ ä¸“ä¸šæœ¯è¯­ã€äººåç­‰ï¼Œæé«˜è¯†åˆ«å‡†ç¡®ç‡ã€‚

- **æ€ä¹ˆç”¨**ï¼šè®¾ç½® â†’ çƒ­è¯ â†’ æ·»åŠ çƒ­è¯
- **æ”¯æŒ**ï¼šä»… WhisperKit æ¨¡å‹æ”¯æŒï¼ˆåç§°ä¸ä»¥ parakeet- å¼€å¤´çš„æ¨¡å‹ï¼‰
- **æ•ˆæœ**ï¼šè½¬å½•æ—¶ä¼šç‰¹åˆ«å…³æ³¨ä½ æ·»åŠ çš„çƒ­è¯ï¼Œæé«˜è¯†åˆ«å‡†ç¡®ç‡

#### 4ï¸âƒ£ **å†å²è®°å½•å¯¹æ¯”**
å¯ä»¥æŸ¥çœ‹å“ªäº›å½•éŸ³è¢«ç¼–è¾‘è¿‡ï¼Œä»¥åŠä¿®æ”¹äº†ä»€ä¹ˆã€‚

- **æ€ä¹ˆç”¨**ï¼šå†å²è®°å½• â†’ æ‰¾åˆ°æ ‡æœ‰"å·²ç¼–è¾‘"çš„æ¡ç›® â†’ ç‚¹å‡»å±•å¼€
- **æ˜¾ç¤º**ï¼šåŸå§‹æ–‡æœ¬ï¼ˆåˆ é™¤çº¿ï¼‰å’Œä¿®æ”¹åçš„è¯æ±‡ï¼ˆçº¢è‰²â†’ç»¿è‰²ï¼‰

---

### ä½¿ç”¨åœºæ™¯

**åœºæ™¯ 1ï¼šå½•éŸ³ä¼šè®®çºªè¦**
1. æŒ‰å¿«æ·é”®å½•éŸ³
2. è¯´å®Œåè‡ªåŠ¨å¼¹å‡ºç¼–è¾‘çª—å£
3. å¿«é€Ÿä¿®æ­£äººåã€ä¸“ä¸šæœ¯è¯­
4. ç‚¹å‡»ç¡®è®¤ï¼Œæ–‡æœ¬è‡ªåŠ¨æ’å…¥ç¬”è®°åº”ç”¨
5. ä¸‹æ¬¡å†è¯´è¿™äº›è¯ï¼Œè¯†åˆ«æ›´å‡†ç¡®

**åœºæ™¯ 2ï¼šå†™ä»£ç æ—¶çš„è¯­éŸ³æ³¨é‡Š**
1. å…ˆåœ¨è®¾ç½®ä¸­æ·»åŠ æŠ€æœ¯çƒ­è¯ï¼ˆ"TypeScript", "async", "await"ï¼‰
2. è¯´è¯æ—¶è¿™äº›è¯ä¼šè¢«ä¼˜å…ˆè¯†åˆ«
3. è¯†åˆ«å®Œç«‹å³ç¼–è¾‘
4. ä¿®æ”¹åè‡ªåŠ¨æ’å…¥ä»£ç ç¼–è¾‘å™¨

**åœºæ™¯ 3ï¼šå¤ç›˜è¯†åˆ«é—®é¢˜**
1. æ‰“å¼€å†å²è®°å½•
2. æŸ¥çœ‹å“ªäº›å†…å®¹è¢«ç¼–è¾‘è¿‡
3. åˆ†æå“ªäº›è¯ç»å¸¸è¯†åˆ«é”™è¯¯
4. æ‰‹åŠ¨æ·»åŠ åˆ°çƒ­è¯åˆ—è¡¨

---

## ğŸ”§ ä¸“ä¸šç‰ˆï¼ˆæŠ€æœ¯ç»†èŠ‚ï¼‰

### æ¶æ„æ¦‚è§ˆ

```
å½•éŸ³ â†’ è½¬å½•ï¼ˆWhisperKit/Parakeetï¼‰â†’ å³æ—¶ç¼–è¾‘çª—å£ â†’ å­¦ä¹ çƒ­è¯ â†’ ä¿å­˜å†å²
                    â†“
              ä½¿ç”¨çƒ­è¯æç¤º
```

---

### åŠŸèƒ½ 1ï¼šå³æ—¶ç¼–è¾‘çª—å£

#### æ¶‰åŠæ–‡ä»¶

**1. TranscriptEditorWindow.swift**
- **ä½œç”¨**ï¼šç®¡ç†æµ®åŠ¨ç¼–è¾‘çª—å£çš„ç”Ÿå‘½å‘¨æœŸ
- **å…³é”®ä¿®æ”¹**ï¼š
  ```swift
  // è¡Œ 99: è®°ä½å½“å‰æ´»è·ƒåº”ç”¨
  private var previousApp: NSRunningApplication?

  // è¡Œ 109: æ˜¾ç¤ºçª—å£å‰ä¿å­˜
  previousApp = NSWorkspace.shared.frontmostApplication

  // è¡Œ 137-139, 149-151: å…³é—­åæ¢å¤ç„¦ç‚¹
  if let previousApp = self?.previousApp {
      previousApp.activate(options: [.activateIgnoringOtherApps])
  }
  ```

**2. TranscriptEditorFeature.swift**
- **ä½œç”¨**ï¼šç¼–è¾‘çª—å£çš„çŠ¶æ€ç®¡ç†å’Œä¸šåŠ¡é€»è¾‘
- **å…³é”®å­—æ®µ**ï¼š
  ```swift
  // è¡Œ 28-36
  var transcript: String              // å½“å‰ç¼–è¾‘çš„æ–‡æœ¬
  var originalTranscript: String      // åŸå§‹è½¬å½•æ–‡æœ¬
  var duration: TimeInterval          // å½•éŸ³æ—¶é•¿
  var sourceAppName: String?          // æ¥æºåº”ç”¨åç§°
  var autoLearn: Bool                 // æ˜¯å¦è‡ªåŠ¨å­¦ä¹ 
  var hasChanges: Bool                // æ˜¯å¦æœ‰ä¿®æ”¹ï¼ˆè®¡ç®—å±æ€§ï¼‰
  ```
- **å…³é”®é€»è¾‘**ï¼š
  ```swift
  // è¡Œ 57-74: ç¡®è®¤æŒ‰é’®ç‚¹å‡»
  case .confirmTapped:
      // æ£€æµ‹ä¿®æ”¹çš„è¯æ±‡
      let corrections = detectCorrections(
          original: state.originalTranscript,
          edited: state.transcript
      )

      // è°ƒç”¨å›è°ƒï¼ˆè§¦å‘ç²˜è´´å’Œå­¦ä¹ ï¼‰
      callbacks?.onConfirm(
          state.transcript,
          state.autoLearn && state.hasChanges,
          corrections
      )
  ```

**3. TranscriptEditorView.swift**
- **ä½œç”¨**ï¼šç¼–è¾‘çª—å£çš„ UI ç•Œé¢
- **UI å…ƒç´ **ï¼š
  - æ–‡æœ¬ç¼–è¾‘æ¡†ï¼ˆæ”¯æŒå¤šè¡Œè¾“å…¥ï¼‰
  - å½•éŸ³æ—¶é•¿æ˜¾ç¤º
  - æ¥æºåº”ç”¨æ˜¾ç¤º
  - "è®°ä½æˆ‘çš„ä¿®æ”¹å¹¶å­¦ä¹ " å¤é€‰æ¡†
  - ç¡®è®¤/å–æ¶ˆæŒ‰é’®

---

### åŠŸèƒ½ 2ï¼šæ™ºèƒ½ç²˜è´´ä¸ç„¦ç‚¹æ¢å¤

#### æ¶‰åŠæ–‡ä»¶

**1. PasteboardClient.swift**
- **é—®é¢˜**ï¼šåŸæœ‰çš„ `paste()` æ–¹æ³•ä¾èµ–ç”¨æˆ·è®¾ç½®ï¼Œåœ¨å³æ—¶ç¼–è¾‘åœºæ™¯ä¸‹ä¸å¯é 
- **è§£å†³æ–¹æ¡ˆ**ï¼šæ–°å¢ `pasteDirectly()` æ–¹æ³•ï¼Œå¿½ç•¥ç”¨æˆ·è®¾ç½®ï¼Œå§‹ç»ˆä½¿ç”¨æœ€å¯é çš„ç²˜è´´æ–¹å¼

**å…³é”®ä¿®æ”¹**ï¼š
```swift
// è¡Œ 23: åœ¨ @DependencyClient ä¸­æ·»åŠ æ¥å£
var pasteDirectly: @Sendable (String) async -> Bool = { _ in false }

// è¡Œ 39-41: æ³¨å†Œå®ç°
pasteDirectly: { text in
    await live.pasteDirectly(text: text)
}

// è¡Œ 92-114: å®ç° pasteDirectly æ–¹æ³•
@MainActor
func pasteDirectly(text: String) async -> Bool {
    let pasteboard = NSPasteboard.general

    // 1. ä¿å­˜å½“å‰å‰ªè´´æ¿å†…å®¹
    let snapshot = PasteboardSnapshot(pasteboard: pasteboard)

    // 2. å†™å…¥æ–°æ–‡æœ¬
    let targetChangeCount = writeAndTrackChangeCount(pasteboard: pasteboard, text: text)
    _ = await waitForPasteboardCommit(targetChangeCount: targetChangeCount)

    // 3. æ‰§è¡Œç²˜è´´ï¼ˆå°è¯• Accessibility APIï¼Œå¤±è´¥åˆ™ä½¿ç”¨ Cmd+Vï¼‰
    let pasteSucceeded = await performPaste(text)

    // 4. æ¢å¤åŸå‰ªè´´æ¿å†…å®¹ï¼ˆ500ms åï¼‰
    if pasteSucceeded {
        let savedSnapshot = snapshot
        Task { @MainActor in
            try? await Task.sleep(for: .milliseconds(500))
            pasteboard.clearContents()
            savedSnapshot.restore(to: pasteboard)
        }
    }

    return pasteSucceeded
}
```

**ç²˜è´´ç­–ç•¥**ï¼š
1. **ä¼˜å…ˆ**ï¼šä½¿ç”¨ macOS Accessibility API ç›´æ¥æ’å…¥æ–‡æœ¬ï¼ˆè¡Œ 374ï¼‰
   ```swift
   AXUIElementSetAttributeValue(focusedElement, kAXSelectedTextAttribute as CFString, text as CFTypeRef)
   ```
2. **é™çº§**ï¼šå¦‚æœ Accessibility API å¤±è´¥ï¼Œä½¿ç”¨ Cmd+V é”®ç›˜äº‹ä»¶
3. **ä¿æŠ¤**ï¼šå§‹ç»ˆæ¢å¤ç”¨æˆ·åŸæœ‰çš„å‰ªè´´æ¿å†…å®¹

---

### åŠŸèƒ½ 3ï¼šè‡ªåŠ¨å­¦ä¹ çƒ­è¯

#### æ¶‰åŠæ–‡ä»¶

**1. TranscriptionFeature.swift**
- **è§¦å‘æ—¶æœº**ï¼šå³æ—¶ç¼–è¾‘çª—å£ç¡®è®¤åï¼ˆè¡Œ 540-570ï¼‰
- **å­¦ä¹ é€»è¾‘**ï¼š
  ```swift
  // è¡Œ 554-570: å¤„ç†ç¼–è¾‘ç»“æœ
  if result.shouldLearn && !result.corrections.isEmpty {
      @Shared(.hexSettings) var settings: HexSettings

      for correction in result.corrections {
          let correctedWord = correction.corrected

          // 1. æ·»åŠ åˆ°çƒ­è¯åˆ—è¡¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
          if !settings.hotwords.contains(correctedWord) {
              settings.hotwords.append(correctedWord)
          }

          // 2. æ·»åŠ åˆ°å­—è¯æ›¿æ¢è§„åˆ™
          settings.wordRemappings[correction.original] = correctedWord
      }
  }
  ```

**å­¦ä¹ å†…å®¹**ï¼š
- **çƒ­è¯åˆ—è¡¨**ï¼šç”¨äºè½¬å½•æ—¶æç¤ºæ¨¡å‹ï¼ˆä»… WhisperKitï¼‰
- **å­—è¯æ›¿æ¢è§„åˆ™**ï¼šç”¨äºåå¤„ç†ä¿®æ­£ï¼ˆæ‰€æœ‰æ¨¡å‹é€šç”¨ï¼‰

---

### åŠŸèƒ½ 4ï¼šçƒ­è¯ç®¡ç†ç•Œé¢

#### æ¶‰åŠæ–‡ä»¶

**1. HotwordsSectionView.swift**
- **ä½ç½®**ï¼šè®¾ç½® â†’ çƒ­è¯
- **UI åŠŸèƒ½**ï¼š
  - æ˜¾ç¤ºå½“å‰çƒ­è¯åˆ—è¡¨ï¼ˆè¡Œ 36-58ï¼‰
  - æ·»åŠ æ–°çƒ­è¯ï¼ˆè¡Œ 65-92ï¼‰
  - åˆ é™¤å•ä¸ªçƒ­è¯ï¼ˆè¡Œ 44-51ï¼‰
  - æ¸…ç©ºå…¨éƒ¨çƒ­è¯ï¼ˆè¡Œ 100-110ï¼‰
  - æ˜¾ç¤ºçƒ­è¯æ•°é‡ï¼ˆè¡Œ 115ï¼‰

**2. SettingsFeature.swift**
- **æ·»åŠ çš„ Actions**ï¼ˆè¡Œ 95-97ï¼‰ï¼š
  ```swift
  case addHotword(String)
  case deleteHotword(at: Int)
  case clearAllHotwords
  ```
- **å®ç°é€»è¾‘**ï¼ˆè¡Œ 222-244ï¼‰ï¼š
  ```swift
  case let .addHotword(word):
      state.hexSettings.hotwords.append(word)
      return .none

  case let .deleteHotword(at: index):
      state.hexSettings.hotwords.remove(at: index)
      return .none

  case .clearAllHotwords:
      state.hexSettings.hotwords.removeAll()
      return .none
  ```

---

### åŠŸèƒ½ 5ï¼šWhisperKit çƒ­è¯é›†æˆ

#### æ¶‰åŠæ–‡ä»¶

**1. TranscriptionClient.swift**

**æ¥å£ä¿®æ”¹**ï¼ˆè¡Œ 26ï¼‰ï¼š
```swift
// æ—§æ¥å£
var transcribe: (URL, String, DecodingOptions, (Progress) -> Void) async throws -> String

// æ–°æ¥å£ï¼ˆæ·»åŠ äº† hotwords å‚æ•°ï¼‰
var transcribe: (URL, String, DecodingOptions, [String], (Progress) -> Void) async throws -> String
```

**çƒ­è¯ç¼–ç å‡½æ•°**ï¼ˆè¡Œ 233-258ï¼‰ï¼š
```swift
private func encodeHotwords(_ hotwords: [String], whisperKit: WhisperKit) -> [Int] {
    guard !hotwords.isEmpty else { return [] }

    // è·å– WhisperKit çš„ tokenizer
    guard let tokenizer = whisperKit.tokenizer else {
        transcriptionLogger.warning("WhisperKit tokenizer not available")
        return []
    }

    var allTokens: [Int] = []
    for hotword in hotwords {
        do {
            // ç¼–ç çƒ­è¯æ–‡æœ¬ä¸º token IDs
            let tokens = try tokenizer.encode(text: hotword)

            // è¿‡æ»¤æ‰ç‰¹æ®Š tokensï¼ˆ<|startoftranscript|>, <|endoftext|> ç­‰ï¼‰
            let filteredTokens = tokens.filter {
                $0 < tokenizer.specialTokens.specialTokenBegin
            }

            allTokens.append(contentsOf: filteredTokens)
        } catch {
            transcriptionLogger.warning("Failed to encode hotword '\(hotword)'")
        }
    }

    return allTokens
}
```

**è½¬å½•æ—¶ä½¿ç”¨çƒ­è¯**ï¼ˆè¡Œ 280-288ï¼‰ï¼š
```swift
// ç¼–ç çƒ­è¯ä¸º prompt tokens
var finalOptions = options
if !hotwords.isEmpty {
    let promptTokens = encodeHotwords(hotwords, whisperKit: whisperKit)
    if !promptTokens.isEmpty {
        finalOptions.promptTokens = promptTokens
        transcriptionLogger.info("Using \(promptTokens.count) prompt tokens for \(hotwords.count) hotwords")
    }
}

// ä½¿ç”¨å¸¦çƒ­è¯çš„ options è¿›è¡Œè½¬å½•
let results = try await whisperKit.transcribe(audioPath: url.path, decodeOptions: finalOptions)
```

**é›†æˆåˆ°è½¬å½•æµç¨‹**ï¼ˆTranscriptionFeature.swift è¡Œ 390-398ï¼‰ï¼š
```swift
@Shared(.hexSettings) var settings: HexSettings
let hotwords = settings.hotwords

let result = try await transcription.transcribe(
    capturedURL,
    model,
    decodeOptions,
    hotwords,  // â† ä¼ é€’çƒ­è¯åˆ—è¡¨
) { _ in }
```

---

### åŠŸèƒ½ 6ï¼šå†å²è®°å½•ä¿®æ”¹å¯¹æ¯”

#### æ¶‰åŠæ–‡ä»¶

**1. TranscriptionHistory.swift**ï¼ˆæ•°æ®æ¨¡å‹ï¼‰
```swift
// è¡Œ 3-20: ä¿®æ”¹è®°å½•ç»“æ„
public struct TextCorrection: Codable, Equatable, Identifiable, Sendable {
    public var id: UUID
    public var original: String      // åŸå§‹è¯æ±‡
    public var corrected: String     // ä¿®æ­£è¯æ±‡
    public var timestamp: Date       // ä¿®æ­£æ—¶é—´
}

// è¡Œ 22-57: Transcript æ‰©å±•
public struct Transcript {
    // ... åŸæœ‰å­—æ®µ ...
    public var originalText: String?           // åŸå§‹è½¬å½•æ–‡æœ¬
    public var corrections: [TextCorrection]   // ä¿®æ”¹è®°å½•
    public var wasEdited: Bool {               // æ˜¯å¦è¢«ç¼–è¾‘ï¼ˆè®¡ç®—å±æ€§ï¼‰
        return originalText != nil && originalText != text
    }
}
```

**2. HistoryFeature.swift**ï¼ˆå†å²è®°å½•é€»è¾‘ï¼‰
- **æ˜¾ç¤ºé€»è¾‘**ï¼ˆè¡Œ 217-299ï¼‰ï¼š
  - æ ‡è®°"å·²ç¼–è¾‘"æ¡ç›®ï¼ˆæ©™è‰²æŒ‰é’®ï¼‰
  - ç‚¹å‡»å±•å¼€/æ”¶èµ·ä¿®æ”¹è¯¦æƒ…
  - æ˜¾ç¤ºåŸå§‹æ–‡æœ¬ï¼ˆåˆ é™¤çº¿æ ·å¼ï¼‰
  - æ˜¾ç¤ºä¿®æ”¹çš„è¯æ±‡å¯¹æ¯”ï¼ˆçº¢è‰²â†’ç»¿è‰²ï¼‰

---

### æ¨¡å‹æ”¯æŒæƒ…å†µ

#### WhisperKit æ¨¡å‹ âœ…
- **æ”¯æŒçƒ­è¯**ï¼šä½¿ç”¨ `DecodingOptions.promptTokens`
- **æ¨¡å‹è¯†åˆ«**ï¼šåç§°ä»¥ `whisper-` æˆ– `distil-` å¼€å¤´
- **ç¼–ç æ–¹å¼**ï¼šä½¿ç”¨ WhisperKit tokenizer ç¼–ç 
- **ç”Ÿæ•ˆé˜¶æ®µ**ï¼šè½¬å½•æ—¶

#### Parakeet TDT æ¨¡å‹ âŒ
- **ä¸æ”¯æŒçƒ­è¯**ï¼šæ¨¡å‹æ¶æ„ä¸æ”¯æŒ prompt å‚æ•°
- **æ¨¡å‹è¯†åˆ«**ï¼šåç§°ä»¥ `parakeet-` å¼€å¤´
- **æ›¿ä»£æ–¹æ¡ˆ**ï¼šä½¿ç”¨å­—è¯æ›¿æ¢åŠŸèƒ½ï¼ˆåå¤„ç†é˜¶æ®µï¼‰
- **ä»£ç æ£€æµ‹**ï¼ˆTranscriptionClient.swift è¡Œ 271ï¼‰ï¼š
  ```swift
  private func isParakeet(_ model: String) -> Bool {
      model.lowercased().hasPrefix("parakeet-")
  }
  ```

---

### å®Œæ•´æ•°æ®æµ

```
1. ç”¨æˆ·æŒ‰å¿«æ·é”®å½•éŸ³
   â†“
2. å½•éŸ³å®Œæˆï¼Œå¼€å§‹è½¬å½•
   â”œâ”€ WhisperKit: ä½¿ç”¨çƒ­è¯ promptTokens
   â””â”€ Parakeet: ä¸ä½¿ç”¨çƒ­è¯
   â†“
3. è½¬å½•å®Œæˆï¼Œå¼¹å‡ºå³æ—¶ç¼–è¾‘çª—å£
   â”œâ”€ è®°ä½å½“å‰æ´»è·ƒåº”ç”¨
   â””â”€ æ˜¾ç¤ºè½¬å½•æ–‡æœ¬
   â†“
4. ç”¨æˆ·ç¼–è¾‘æ–‡æœ¬
   â”œâ”€ ä¿®æ”¹è¯†åˆ«é”™è¯¯çš„è¯æ±‡
   â””â”€ å‹¾é€‰"è®°ä½æˆ‘çš„ä¿®æ”¹å¹¶å­¦ä¹ "
   â†“
5. ç‚¹å‡»"ç¡®è®¤å¹¶ç²˜è´´"
   â”œâ”€ æ£€æµ‹ä¿®æ”¹çš„è¯æ±‡ (detectCorrections)
   â”œâ”€ ä¿å­˜ä¿®æ”¹è®°å½• (TextCorrection)
   â”œâ”€ è‡ªåŠ¨å­¦ä¹ çƒ­è¯ (æ·»åŠ åˆ° hotwords)
   â”œâ”€ æ·»åŠ å­—è¯æ›¿æ¢è§„åˆ™ (wordRemappings)
   â”œâ”€ ä½¿ç”¨ pasteDirectly ç²˜è´´æ–‡æœ¬
   â””â”€ æ¢å¤ç„¦ç‚¹åˆ°åŸåº”ç”¨
   â†“
6. ä¿å­˜åˆ°å†å²è®°å½•
   â”œâ”€ åŸå§‹æ–‡æœ¬ (originalText)
   â”œâ”€ ä¿®æ”¹åæ–‡æœ¬ (text)
   â””â”€ ä¿®æ”¹è®°å½•åˆ—è¡¨ (corrections)
```

---

### å…³é”®æŠ€æœ¯ç‚¹

1. **TCA æ¶æ„**ï¼šä½¿ç”¨ The Composable Architecture ç®¡ç†çŠ¶æ€
2. **ä¾èµ–æ³¨å…¥**ï¼šé€šè¿‡ `@Dependency` æ³¨å…¥å®¢æˆ·ç«¯
3. **å…±äº«çŠ¶æ€**ï¼šé€šè¿‡ `@Shared(.hexSettings)` æŒä¹…åŒ–è®¾ç½®
4. **å¼‚æ­¥å›è°ƒ**ï¼šä½¿ç”¨ `withCheckedContinuation` æ¡¥æ¥ TCA å’Œçª—å£å›è°ƒ
5. **Actor éš”ç¦»**ï¼šä½¿ç”¨ `@MainActor` ç¡®ä¿ UI æ“ä½œåœ¨ä¸»çº¿ç¨‹
6. **å‰ªè´´æ¿ä¿æŠ¤**ï¼šä¿å­˜å’Œæ¢å¤ç”¨æˆ·åŸæœ‰å‰ªè´´æ¿å†…å®¹
7. **ç„¦ç‚¹ç®¡ç†**ï¼šè®°ä½å’Œæ¢å¤å‰å°åº”ç”¨
8. **Token ç¼–ç **ï¼šä½¿ç”¨ WhisperKit tokenizer ç¼–ç çƒ­è¯
9. **ç‰¹æ®Š Token è¿‡æ»¤**ï¼šè¿‡æ»¤ `specialTokenBegin` ä»¥ä¸Šçš„ token ID

---

### å·²çŸ¥é—®é¢˜

#### WhisperKit promptTokens å¯èƒ½å¯¼è‡´ç©ºç»“æœ
- **é—®é¢˜æè¿°**ï¼šæ ¹æ® [WhisperKit Issue #372](https://github.com/argmaxinc/WhisperKit/issues/372)ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ä½¿ç”¨ `promptTokens` å¯èƒ½å¯¼è‡´è½¬å½•è¿”å›ç©ºç»“æœ
- **ä¸´æ—¶è§£å†³æ–¹æ¡ˆ**ï¼š
  1. åœ¨è®¾ç½®ä¸­æ¸…ç©ºçƒ­è¯åˆ—è¡¨
  2. æˆ–è€…åªä½¿ç”¨å­—è¯æ›¿æ¢åŠŸèƒ½ï¼ˆåå¤„ç†ï¼‰
- **ç›‘æ§**ï¼šå…³æ³¨ WhisperKit çš„æ›´æ–°å’Œ bug ä¿®å¤

---

### æ–‡ä»¶æ¸…å•

| æ–‡ä»¶è·¯å¾„ | ä¿®æ”¹ç±»å‹ | ä¸»è¦æ”¹åŠ¨ |
|---------|---------|---------|
| `Hex/Features/TranscriptEditor/TranscriptEditorWindow.swift` | ä¿®æ”¹ | æ·»åŠ ç„¦ç‚¹æ¢å¤é€»è¾‘ |
| `Hex/Features/TranscriptEditor/TranscriptEditorFeature.swift` | ä¿®æ”¹ | æ·»åŠ ä¿®æ”¹æ£€æµ‹é€»è¾‘ |
| `Hex/Features/TranscriptEditor/TranscriptEditorView.swift` | æ–°å»º | ç¼–è¾‘çª—å£ UI |
| `Hex/Features/Transcription/TranscriptionFeature.swift` | ä¿®æ”¹ | é›†æˆå³æ—¶ç¼–è¾‘ã€è‡ªåŠ¨å­¦ä¹  |
| `Hex/Clients/PasteboardClient.swift` | ä¿®æ”¹ | æ·»åŠ  pasteDirectly æ–¹æ³• |
| `Hex/Clients/TranscriptionClient.swift` | ä¿®æ”¹ | æ·»åŠ çƒ­è¯ç¼–ç å’Œé›†æˆ |
| `Hex/Features/Settings/HotwordsSectionView.swift` | æ–°å»º | çƒ­è¯ç®¡ç†ç•Œé¢ |
| `Hex/Features/Settings/SettingsFeature.swift` | ä¿®æ”¹ | æ·»åŠ çƒ­è¯ç®¡ç† Actions |
| `Hex/Features/Settings/SettingsView.swift` | ä¿®æ”¹ | æ·»åŠ  HotwordsSectionView |
| `Hex/Features/History/HistoryFeature.swift` | ä¿®æ”¹ | æ·»åŠ ä¿®æ”¹å¯¹æ¯”æ˜¾ç¤º |
| `HexCore/Sources/HexCore/Models/TranscriptionHistory.swift` | ä¿®æ”¹ | æ·»åŠ  TextCorrection ç»“æ„ |
| `HexCore/Sources/HexCore/Models/HexSettings.swift` | ä¿®æ”¹ | æ·»åŠ  hotwords å­—æ®µ |

---

## ğŸ§ª æµ‹è¯•æ¸…å•

- [x] å³æ—¶ç¼–è¾‘çª—å£å¼¹å‡ºå’Œå…³é—­
- [x] ç„¦ç‚¹è‡ªåŠ¨æ¢å¤åˆ°åŸåº”ç”¨
- [x] pasteDirectly ç²˜è´´æˆåŠŸ
- [x] å‰ªè´´æ¿å†…å®¹æ¢å¤
- [x] è‡ªåŠ¨å­¦ä¹ çƒ­è¯ï¼ˆä»ä¿®æ”¹ä¸­ï¼‰
- [x] æ‰‹åŠ¨æ·»åŠ /åˆ é™¤çƒ­è¯
- [x] WhisperKit è½¬å½•ä½¿ç”¨çƒ­è¯
- [x] å†å²è®°å½•æ˜¾ç¤ºä¿®æ”¹å¯¹æ¯”
- [ ] éªŒè¯çƒ­è¯åœ¨å®é™…è½¬å½•ä¸­çš„æ•ˆæœæå‡
- [ ] é•¿æœŸç›‘æ§ WhisperKit promptTokens çš„ç¨³å®šæ€§

---

---

## ğŸ†• æ¨¡å‹æ”¯æŒæ‰©å±•ï¼ˆ2026å¹´2æœˆï¼‰

### åŠŸèƒ½ 7ï¼šå¤šæ¨¡å‹æ”¯æŒä¸ä¼˜åŒ–

#### é—®é¢˜å‘ç°ä¸è§£å†³

**é—®é¢˜èƒŒæ™¯**ï¼š
åœ¨å®é™…ä½¿ç”¨ä¸­å‘ç° WhisperKit çš„ large-v3 ç³»åˆ—æ¨¡å‹å­˜åœ¨ä¸¥é‡çš„ promptTokens bugï¼š
- âŒ `openai_whisper-large-v3-v20240930`ï¼ˆ1.5GB Turbo ç‰ˆï¼‰- decoder_layers=4ï¼ŒpromptTokens å¯¼è‡´ç©ºç»“æœ
- âŒ `openai_whisper-large-v3_947MB`ï¼ˆå®Œæ•´ç‰ˆï¼‰- decoder_layers=32ï¼ŒpromptTokens ä»å¯¼è‡´ç©ºç»“æœ

**æ ¹æœ¬åŸå› **ï¼š
æ ¹æ® [WhisperKit Issue #372](https://github.com/argmaxinc/WhisperKit/issues/372)ï¼Œæ‰€æœ‰ large-v3 å˜ä½“åœ¨ä½¿ç”¨ promptTokens æ—¶éƒ½ä¼šè§¦å‘ `kAudioUnitErr_TooManyFramesToProcess` é”™è¯¯ï¼ˆé”™è¯¯ç  -10874ï¼‰ã€‚

**é”™è¯¯æ—¥å¿—ç¤ºä¾‹**ï¼š
```
ğŸ”¥ Hotwords provided: claude, ...
Encoded 4 hotwords into 52 tokens
âœ… Using 52 prompt tokens for 4 hotwords
Transcribing with WhisperKit model=openai_whisper-large-v3_947MB
from AU (0x89db5232): aumx/mcmx/appl, render err: -10874
kAudioUnitErr_TooManyFramesToProcess : inFramesToProcess=882, mMaxFramesPerSlice=320
WhisperKit transcription took 2.58s
Transcribed audio ... to text length 0  â† ç©ºç»“æœ
```

#### è§£å†³æ–¹æ¡ˆï¼šæ¨¡å‹æ¸…ç†ä¸ Qwen3-ASR é›†æˆ

**1. åˆ é™¤ä¸æ”¯æŒçƒ­è¯çš„æ¨¡å‹**

ç§»é™¤ä»¥ä¸‹æ¨¡å‹ï¼ˆä¸æ”¯æŒä¸­æ–‡æˆ–ä¸æ”¯æŒçƒ­è¯ï¼‰ï¼š
- âŒ Parakeet TDT v2/v3 - ä¸æ”¯æŒçƒ­è¯
- âŒ Whisper Large v3 (æ‰€æœ‰å˜ä½“) - promptTokens æœ‰ bug
- âŒ Distil Whisper Large v3 - ä»…æ”¯æŒè‹±è¯­

**2. ä¿ç•™çš„ WhisperKit æ¨¡å‹**

| æ¨¡å‹ | å¤§å° | decoder_layers | çƒ­è¯æ”¯æŒ | ä¸­æ–‡æ”¯æŒ | éªŒè¯çŠ¶æ€ |
|------|------|----------------|---------|---------|---------|
| Whisper Tiny | 73MB | 4 | âœ… | âœ… | ç†è®ºæ”¯æŒ |
| **Whisper Base** | 140MB | 6 | âœ… | âœ… | **å·²éªŒè¯å¯ç”¨** |
| Whisper Small | 466MB | 12 | âœ… | âœ… | ç†è®ºæ”¯æŒ |
| Whisper Medium | 1.5GB | 24 | âœ… | âœ… | ç†è®ºæ”¯æŒ |

**3. é›†æˆ Qwen3-ASR æ¨¡å‹**

ä¸ºäº†æä¾›æ›´å¥½çš„ä¸­æ–‡å’Œå¤šè¯­è¨€æ”¯æŒï¼Œé›†æˆäº†é˜¿é‡Œäº‘é€šä¹‰åƒé—® Qwen3-ASRï¼š

| æ¨¡å‹ | å¤§å° | å‚æ•°é‡ | è¯­è¨€æ”¯æŒ | ä¸­æ–‡æ–¹è¨€ | å‡†ç¡®ç‡ | é€Ÿåº¦ |
|------|------|--------|---------|---------|--------|------|
| **Qwen3-ASR 0.6B** | 1.2GB | 600M | 52ç§è¯­è¨€ | 22ç§ | â­â­â­â­â­ | â­â­â­â­ |
| **Qwen3-ASR 1.7B** | 3.4GB | 1.7B | 52ç§è¯­è¨€ | 22ç§ | â­â­â­â­â­ | â­â­â­ |

**Qwen3-ASR ç‰¹æ€§**ï¼š
- âœ… æ”¯æŒ 52 ç§è¯­è¨€å’Œ 22 ç§ä¸­æ–‡æ–¹è¨€ï¼ˆç²¤è¯­ã€å››å·è¯ã€ä¸œåŒ—è¯ç­‰ï¼‰
- âœ… SOTA çº§åˆ«å‡†ç¡®ç‡ï¼ˆä¸å•†ä¸š API ç«äº‰ï¼‰
- âœ… æ”¯æŒéŸ³ä¹/æ­Œæ›²è¯†åˆ«
- âœ… è‡ªåŠ¨è¯­è¨€æ£€æµ‹
- âœ… æ—¶é—´æˆ³é¢„æµ‹
- âœ… åœ¨å™ªéŸ³ã€ä½è´¨é‡ã€è¿œåœºç¯å¢ƒä¸‹è¡¨ç°ä¼˜ç§€
- âœ… å®Œå…¨æœ¬åœ°åŒ–æ¨ç†ï¼ˆåŸºäº Apple MLX æ¡†æ¶ï¼‰

---

### åŠŸèƒ½ 8ï¼šQwen3-ASR é›†æˆå®ç°

#### æŠ€æœ¯é€‰å‹

ä½¿ç”¨ **MLX-Audio Swift**ï¼ˆhttps://github.com/Blaizzy/mlx-audio-swiftï¼‰ï¼š
- åŸç”Ÿ Swift å®ç°
- åŸºäº Apple MLX æ¡†æ¶ï¼ˆæ¯” CoreML æ›´ç°ä»£ï¼‰
- æè‡´æ€§èƒ½å’Œä½åŠŸè€—
- å®Œå…¨æœ¬åœ°åŒ–

#### æ–°å¢æ–‡ä»¶

**1. Qwen3ASRClient.swift**

**æ–‡ä»¶ä½ç½®**ï¼š`Hex/Clients/Qwen3ASRClient.swift`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
```swift
@DependencyClient
struct Qwen3ASRClient {
  // è½¬å½•éŸ³é¢‘æ–‡ä»¶
  var transcribe: @Sendable (URL, String, [String]) async throws -> String

  // ä¸‹è½½æ¨¡å‹ï¼ˆä» Hugging Faceï¼‰
  var downloadModel: @Sendable (String, @escaping (Progress) -> Void) async throws -> Void

  // åˆ é™¤æ¨¡å‹
  var deleteModel: @Sendable (String) async throws -> Void

  // æ£€æŸ¥æ¨¡å‹æ˜¯å¦å·²ä¸‹è½½
  var isModelDownloaded: @Sendable (String) async -> Bool

  // è·å–å¯ç”¨æ¨¡å‹åˆ—è¡¨
  var getAvailableModels: @Sendable () async -> [String]
}
```

**æ¨¡å‹æ˜ å°„**ï¼š
```swift
private let modelMapping: [String: String] = [
  "qwen3-asr-0.6b": "mlx-community/Qwen3-ASR-0.6B-8bit",
  "qwen3-asr-1.7b": "mlx-community/Qwen3-ASR-1.7B-8bit",
]
```

**å…³é”®å®ç°**ï¼š

1. **éŸ³é¢‘åŠ è½½**ï¼š
```swift
private func loadAudioArray(from url: URL) throws -> (sampleRate: Float, audio: [Float]) {
    let audioFile = try AVAudioFile(forReading: url)
    let format = audioFile.processingFormat
    // è½¬æ¢ä¸º Float æ•°ç»„
    // å¦‚æœæ˜¯ç«‹ä½“å£°ï¼Œè½¬æ¢ä¸ºå•å£°é“ï¼ˆå–å¹³å‡å€¼ï¼‰
    return (Float(format.sampleRate), audioData)
}
```

2. **è½¬å½•é€»è¾‘**ï¼š
```swift
func transcribe(url: URL, modelName: String, hotwords: [String]) async throws -> String {
    // 1. ç¡®ä¿æ¨¡å‹å·²åŠ è½½
    try await ensureModelLoaded(modelName)

    // 2. åŠ è½½éŸ³é¢‘
    let (sampleRate, audioData) = try loadAudioArray(from: url)

    // 3. æ‰§è¡Œè½¬å½•
    let output = try await model.generate(audio: audioData)

    // 4. åº”ç”¨çƒ­è¯åå¤„ç†ï¼ˆå¦‚æœéœ€è¦ï¼‰
    return output.text
}
```

3. **æ¨¡å‹ä¸‹è½½**ï¼š
```swift
func downloadModel(modelName: String, progressCallback: @escaping (Progress) -> Void) async throws {
    // ä½¿ç”¨ MLXAudio çš„æ¨¡å‹åŠ è½½åŠŸèƒ½
    // è‡ªåŠ¨ä» Hugging Face ä¸‹è½½åˆ° ~/.cache/huggingface
    let model = try await STTModel.load(
        repoID: huggingFaceID,
        progressCallback: { percentage in
            progress.completedUnitCount = Int64(percentage * 100)
            progressCallback(progress)
        }
    )
}
```

#### é›†æˆåˆ° TranscriptionClient

**ä¿®æ”¹æ–‡ä»¶**ï¼š`Hex/Clients/TranscriptionClient.swift`

**1. æ·»åŠ  Qwen æ£€æµ‹å‡½æ•°**ï¼š
```swift
private func isQwen(_ name: String) -> Bool {
    name.lowercased().hasPrefix("qwen3-asr")
}
```

**2. ä¿®æ”¹è½¬å½•è·¯ç”±**ï¼š
```swift
func transcribe(...) async throws -> String {
    let startAll = Date()

    // Qwen3-ASR è·¯ç”±
    if isQwen(model) {
        transcriptionLogger.notice("Using Qwen3-ASR for transcription: \(model)")
        @Dependency(\.qwen3ASR) var qwen
        let result = try await qwen.transcribe(url, model, hotwords)
        return result
    }

    // Parakeet è·¯ç”±
    if isParakeet(model) { ... }

    // WhisperKit è·¯ç”±ï¼ˆé»˜è®¤ï¼‰
    ...
}
```

**3. ä¿®æ”¹æ¨¡å‹ä¸‹è½½è·¯ç”±**ï¼š
```swift
func downloadAndLoadModel(variant: String, ...) async throws {
    if isQwen(variant) {
        @Dependency(\.qwen3ASR) var qwen
        try await qwen.downloadModel(variant, progressCallback)
        currentModelName = variant
        return
    }

    if isParakeet(variant) { ... }

    // WhisperKit é€»è¾‘
    ...
}
```

**4. ä¿®æ”¹æ¨¡å‹åˆ é™¤å’ŒçŠ¶æ€æ£€æŸ¥**ï¼š
```swift
func deleteModel(variant: String) async throws {
    if isQwen(variant) {
        @Dependency(\.qwen3ASR) var qwen
        try await qwen.deleteModel(variant)
        return
    }
    ...
}

func isModelDownloaded(_ modelName: String) async -> Bool {
    if isQwen(modelName) {
        @Dependency(\.qwen3ASR) var qwen
        return await qwen.isModelDownloaded(modelName)
    }
    ...
}
```

#### æ›´æ–° UI é…ç½®

**1. ä¿®æ”¹ ModelDownloadFeature.swift**

æ·»åŠ ä¸­æ–‡å­—æ®µæ”¯æŒï¼š
```swift
public struct CuratedModelInfo: Equatable, Identifiable, Codable {
    public let displayName: String
    public let displayName_zh: String?      // æ–°å¢
    public let internalName: String
    public let size: String
    public let size_zh: String?             // æ–°å¢
    ...
}
```

æ·»åŠ  Qwen å¾½ç« ï¼š
```swift
public var badge: String? {
    if internalName == "parakeet-tdt-0.6b-v2-coreml" {
        return "BEST FOR ENGLISH"
    } else if internalName == "parakeet-tdt-0.6b-v3-coreml" {
        return "BEST FOR MULTILINGUAL"
    } else if internalName.hasPrefix("qwen3-asr") {
        return "BEST FOR CHINESE"  // æ–°å¢
    }
    return nil
}
```

**2. æ›´æ–° models.json**

**æ–‡ä»¶ä½ç½®**ï¼š`Hex/Resources/Data/models.json`

```json
[
  {
    "displayName": "Whisper Small (Tiny)",
    "displayName_zh": "Whisper å°å‹ï¼ˆæå°ï¼‰",
    "internalName": "openai_whisper-tiny",
    "size": "Multilingual",
    "size_zh": "å¤šè¯­è¨€",
    "accuracyStars": 2,
    "speedStars": 4,
    "storageSize": "73MB"
  },
  {
    "displayName": "Whisper Medium (Base)",
    "displayName_zh": "Whisper ä¸­å‹ï¼ˆåŸºç¡€ï¼‰",
    "internalName": "openai_whisper-base",
    "size": "Multilingual",
    "size_zh": "å¤šè¯­è¨€",
    "accuracyStars": 3,
    "speedStars": 3,
    "storageSize": "140MB"
  },
  {
    "displayName": "Whisper Small",
    "displayName_zh": "Whisper å°å‹",
    "internalName": "openai_whisper-small",
    "size": "Multilingual",
    "size_zh": "å¤šè¯­è¨€",
    "accuracyStars": 3,
    "speedStars": 3,
    "storageSize": "466MB"
  },
  {
    "displayName": "Whisper Medium",
    "displayName_zh": "Whisper ä¸­å‹",
    "internalName": "openai_whisper-medium",
    "size": "Multilingual",
    "size_zh": "å¤šè¯­è¨€",
    "accuracyStars": 4,
    "speedStars": 2,
    "storageSize": "1.5GB"
  },
  {
    "displayName": "Qwen3-ASR 0.6B",
    "displayName_zh": "é€šä¹‰åƒé—® ASR 0.6B",
    "internalName": "qwen3-asr-0.6b",
    "size": "Multilingual (52 languages)",
    "size_zh": "å¤šè¯­è¨€ï¼ˆ52ç§è¯­è¨€+22ç§ä¸­æ–‡æ–¹è¨€ï¼‰",
    "accuracyStars": 5,
    "speedStars": 4,
    "storageSize": "1.2GB"
  },
  {
    "displayName": "Qwen3-ASR 1.7B",
    "displayName_zh": "é€šä¹‰åƒé—® ASR 1.7B",
    "internalName": "qwen3-asr-1.7b",
    "size": "Multilingual (52 languages)",
    "size_zh": "å¤šè¯­è¨€ï¼ˆ52ç§è¯­è¨€+22ç§ä¸­æ–‡æ–¹è¨€ï¼‰",
    "accuracyStars": 5,
    "speedStars": 3,
    "storageSize": "3.4GB"
  }
]
```

---

### æ–°å¢æ–‡ä»¶æ¸…å•

| æ–‡ä»¶è·¯å¾„ | ç±»å‹ | è¯´æ˜ |
|---------|------|------|
| `Hex/Clients/Qwen3ASRClient.swift` | æ–°å»º | Qwen3-ASR å®¢æˆ·ç«¯å®ç° |
| `Hex/Clients/TranscriptionClient.swift` | ä¿®æ”¹ | æ·»åŠ  Qwen è·¯ç”±é€»è¾‘ |
| `Hex/Features/Settings/ModelDownload/ModelDownloadFeature.swift` | ä¿®æ”¹ | æ”¯æŒä¸­æ–‡å­—æ®µå’Œ Qwen å¾½ç«  |
| `Hex/Resources/Data/models.json` | ä¿®æ”¹ | æ·»åŠ  Qwen æ¨¡å‹é…ç½® |
| `Hex/QWEN_ASR_INTEGRATION_PLAN.md` | æ–°å»º | æŠ€æœ¯å®ç°è®¡åˆ’ï¼ˆè¯¦ç»†ï¼‰ |
| `Hex/QWEN_INTEGRATION_COMPLETE.md` | æ–°å»º | é›†æˆå®ŒæˆæŒ‡å—ï¼ˆæµ‹è¯•ï¼‰ |

---

### ä¾èµ–æ·»åŠ 

**Swift Package Manager ä¾èµ–**ï¼š
- **MLX-Audio Swift**: https://github.com/Blaizzy/mlx-audio-swift
- äº§å“ï¼š`MLXAudio`

**æ·»åŠ æ–¹å¼**ï¼š
1. File â†’ Add Package Dependencies...
2. è¾“å…¥ URLï¼š`https://github.com/Blaizzy/mlx-audio-swift`
3. é€‰æ‹© `main` åˆ†æ”¯
4. æ·»åŠ  `MLXAudio` äº§å“

---

### æµ‹è¯•éªŒè¯æ­¥éª¤

#### 1. ç¼–è¯‘éªŒè¯
```bash
cd /Users/marvin/antigravity/hex/Hex
xcodebuild -scheme Hex -configuration Debug clean build
```

#### 2. åŠŸèƒ½æµ‹è¯•

**æµ‹è¯• Qwen3-ASR 0.6B**ï¼š
1. å¯åŠ¨åº”ç”¨ â†’ è®¾ç½® â†’ æ¨¡å‹
2. é€‰æ‹© "Qwen3-ASR 0.6B"
3. ç‚¹å‡»ä¸‹è½½ï¼Œç­‰å¾…å®Œæˆ
4. å½•åˆ¶ä¸­æ–‡éŸ³é¢‘æµ‹è¯•è½¬å½•

**æµ‹è¯•çƒ­è¯åŠŸèƒ½**ï¼š
1. è®¾ç½® â†’ çƒ­è¯ â†’ æ·»åŠ  "Claude"ã€"é€šä¹‰åƒé—®"
2. å½•éŸ³è¯´åŒ…å«çƒ­è¯çš„å¥å­
3. éªŒè¯è¯†åˆ«å‡†ç¡®ç‡

**æµ‹è¯•ä¸­æ–‡æ–¹è¨€**ï¼š
- ç²¤è¯­ï¼š"ä½ å¥½ï¼Œå‘¢å€‹ä¿‚æ¸¬è©¦"
- å››å·è¯ï¼š"ä½ å¥½ï¼Œè¿™æ˜¯ä¸ªæµ‹è¯•å“ˆ"

#### 3. æ€§èƒ½é¢„æœŸ

**Qwen3-ASR 0.6B**ï¼š
- æ¨¡å‹åŠ è½½ï¼š3-5ç§’
- è½¬å½•é€Ÿåº¦ï¼š0.5-1ç§’/ç§’éŸ³é¢‘
- å†…å­˜å ç”¨ï¼š~2GB
- ä¸­æ–‡å‡†ç¡®ç‡ï¼š>95%

**Qwen3-ASR 1.7B**ï¼š
- æ¨¡å‹åŠ è½½ï¼š5-8ç§’
- è½¬å½•é€Ÿåº¦ï¼š1-2ç§’/ç§’éŸ³é¢‘
- å†…å­˜å ç”¨ï¼š~4GB
- ä¸­æ–‡å‡†ç¡®ç‡ï¼š>97%

---

### æ¨¡å‹å¯¹æ¯”æ€»ç»“

| æ¨¡å‹ | å¤§å° | è¯­è¨€ | æ–¹è¨€ | çƒ­è¯ | å‡†ç¡®ç‡ | é€Ÿåº¦ | éªŒè¯çŠ¶æ€ |
|------|------|------|------|------|--------|------|---------|
| Whisper Tiny | 73MB | 99ç§ | âŒ | âœ… | â­â­ | â­â­â­â­ | ç†è®ºæ”¯æŒ |
| **Whisper Base** | 140MB | 99ç§ | âŒ | âœ… | â­â­â­ | â­â­â­ | **å·²éªŒè¯** |
| Whisper Small | 466MB | 99ç§ | âŒ | âœ… | â­â­â­ | â­â­â­ | ç†è®ºæ”¯æŒ |
| Whisper Medium | 1.5GB | 99ç§ | âŒ | âœ… | â­â­â­â­ | â­â­ | ç†è®ºæ”¯æŒ |
| **Qwen3-ASR 0.6B** | 1.2GB | 52ç§ | âœ… 22ç§ | âœ… | â­â­â­â­â­ | â­â­â­â­ | å¾…éªŒè¯ |
| **Qwen3-ASR 1.7B** | 3.4GB | 52ç§ | âœ… 22ç§ | âœ… | â­â­â­â­â­ | â­â­â­ | å¾…éªŒè¯ |

---

### å‚è€ƒèµ„æ–™

#### Qwen3-ASR
- [Qwen3-ASR GitHub](https://github.com/QwenLM/Qwen3-ASR)
- [Qwen3-ASR æŠ€æœ¯æŠ¥å‘Š](https://arxiv.org/html/2601.21337v1)
- [Qwen3-ASR å®˜ç½‘](https://qwenasr.com/)
- [MLX-Community æ¨¡å‹](https://huggingface.co/mlx-community/Qwen3-ASR-0.6B-8bit)

#### MLX-Audio
- [MLX-Audio Swift GitHub](https://github.com/Blaizzy/mlx-audio-swift)
- [MLX-Audio Python](https://github.com/Blaizzy/mlx-audio)
- [MLX Swift API](https://github.com/ml-explore/mlx-swift)

#### WhisperKit Issue
- [Issue #372: promptTokens å¯¼è‡´ç©ºç»“æœ](https://github.com/argmaxinc/WhisperKit/issues/372)
- [WhisperKit GitHub](https://github.com/argmaxinc/WhisperKit)
- [WhisperKit CoreML æ¨¡å‹](https://huggingface.co/argmaxinc/whisperkit-coreml)

---

## ğŸ“Œ æ€»ç»“

è¿™æ¬¡ä¿®æ”¹å®ç°äº†ä¸€ä¸ªå®Œæ•´çš„"å½•éŸ³ â†’ è½¬å½• â†’ ç¼–è¾‘ â†’ å­¦ä¹  â†’ ä¼˜åŒ–"çš„é—­ç¯ï¼š

### ç¬¬ä¸€é˜¶æ®µï¼ˆç¼–è¾‘åŠŸèƒ½ï¼‰
1. **å³æ—¶åé¦ˆ**ï¼šè½¬å½•å®Œç«‹å³ç¼–è¾‘ï¼Œä¸æ‰“æ–­å·¥ä½œæµ
2. **è‡ªåŠ¨å­¦ä¹ **ï¼šç³»ç»Ÿè®°ä½ä½ çš„ä¿®æ”¹ï¼Œè¶Šç”¨è¶Šå‡†
3. **æ‰‹åŠ¨å¹²é¢„**ï¼šå¯ä»¥æå‰æ·»åŠ ä¸“ä¸šæœ¯è¯­
4. **å†å²è¿½æº¯**ï¼šå¯ä»¥å›çœ‹å“ªäº›å†…å®¹è¢«ä¿®æ”¹è¿‡
5. **æ™ºèƒ½ç²˜è´´**ï¼šè‡ªåŠ¨æ’å…¥æ–‡æœ¬ï¼Œè‡ªåŠ¨æ¢å¤ç„¦ç‚¹å’Œå‰ªè´´æ¿

### ç¬¬äºŒé˜¶æ®µï¼ˆæ¨¡å‹ä¼˜åŒ–ï¼‰
6. **é—®é¢˜æ’æŸ¥**ï¼šå‘ç°å¹¶ç¡®è®¤ WhisperKit large-v3 çš„ promptTokens bug
7. **æ¨¡å‹æ¸…ç†**ï¼šç§»é™¤ä¸æ”¯æŒçƒ­è¯æˆ–ä¸æ”¯æŒä¸­æ–‡çš„æ¨¡å‹
8. **å¤šå¼•æ“æ”¯æŒ**ï¼šé›†æˆ Qwen3-ASRï¼Œæä¾› SOTA çº§åˆ«çš„ä¸­æ–‡å’Œå¤šè¯­è¨€æ”¯æŒ
9. **æ–¹è¨€è¯†åˆ«**ï¼šæ”¯æŒ 22 ç§ä¸­æ–‡æ–¹è¨€ï¼ˆç²¤è¯­ã€å››å·è¯ç­‰ï¼‰
10. **æ¶æ„å‡çº§**ï¼šå¼•å…¥ Apple MLX æ¡†æ¶ï¼Œæ€§èƒ½å’ŒåŠŸè€—æ›´ä¼˜

### æŠ€æœ¯äº®ç‚¹
- âœ… å®Œæ•´çš„ TCA æ¶æ„å®ç°
- âœ… å¤šå¼•æ“æ™ºèƒ½è·¯ç”±ï¼ˆWhisperKit / Qwen3-ASRï¼‰
- âœ… çƒ­è¯åŠŸèƒ½å®Œæ•´å®ç°ï¼ˆç¼–ç ã€ä¼ é€’ã€å­¦ä¹ ï¼‰
- âœ… ä¼˜é›…çš„é”™è¯¯å¤„ç†å’Œé™çº§ç­–ç•¥
- âœ… å®Œå…¨æœ¬åœ°åŒ–æ¨ç†ï¼Œä¿æŠ¤éšç§

ç”¨æˆ·ä½“éªŒæµç•…ï¼ŒæŠ€æœ¯å®ç°ç¨³å¥ï¼Œæ¨¡å‹æ”¯æŒå…¨é¢ã€‚ğŸš€

---

## ğŸ”§ ç¬¬ä¸‰é˜¶æ®µï¼šæ ¸å¿ƒä½“éªŒä¼˜åŒ–ï¼ˆ2026å¹´2æœˆï¼‰

### åŠŸèƒ½ 9ï¼šæ™ºèƒ½çƒ­è¯å­¦ä¹ ä¼˜åŒ–

#### é—®é¢˜èƒŒæ™¯

ä¹‹å‰çš„çƒ­è¯å­¦ä¹ é€»è¾‘å­˜åœ¨ä¸¤ä¸ªå…³é”®é—®é¢˜ï¼š

1. **æ•´å¥è¯†åˆ«é—®é¢˜**ï¼šå½“ç”¨æˆ·ä¿®æ”¹ä¸€å¤§æ®µæ–‡æœ¬æ—¶ï¼Œç³»ç»Ÿä¼šæŠŠæ•´ä¸ªä¿®æ”¹åçš„å¥å­å½“ä½œä¸€ä¸ªçƒ­è¯
2. **ä¸­è‹±æ–‡å¤„ç†ä¸ç»Ÿä¸€**ï¼šæ²¡æœ‰é’ˆå¯¹ä¸­æ–‡è¯­å¢ƒè¿›è¡Œä¼˜åŒ–

**ç¤ºä¾‹é—®é¢˜**ï¼š
```
åŸæ–‡ï¼š"Anti-Gravity claude. claude Agency. Anthropicç­‰æ¦‚å¿µ..."
ä¿®æ”¹ï¼š"Antigravity Claude Agent anthropicç­‰æ¦‚å¿µ..."

æ—§é€»è¾‘ï¼šæ·»åŠ æ•´å¥ä½œä¸ºçƒ­è¯ âŒ
æ–°é€»è¾‘ï¼šæå– "Antigravity", "Claude", "Agent" ä¸‰ä¸ªè¯ âœ…
```

#### è§£å†³æ–¹æ¡ˆï¼šæ™ºèƒ½åˆ†è¯ä¸è¯­è¨€è¯†åˆ«

**æ¶‰åŠæ–‡ä»¶**ï¼š`Hex/Features/Transcription/TranscriptionFeature.swift`

**1. ç»Ÿä¸€çš„è¯è¯­æå–ç­–ç•¥**ï¼ˆè¡Œ 562-591ï¼‰

```swift
// Extract meaningful words from the corrected text and add them as hotwords
// Strategy: Always split by whitespace and extract individual words,
// filtering out common words and short words

let correctedText = correction.corrected.trimmingCharacters(in: .whitespacesAndNewlines)

// Split by whitespace to get individual words
let words = correctedText.split(separator: " ").map {
    String($0).trimmingCharacters(in: .punctuationCharacters)
}

for word in words {
    guard !word.isEmpty else { continue }

    // Check if this word contains Chinese characters
    let containsChinese = word.rangeOfCharacter(
        from: CharacterSet(charactersIn: "\u{4E00}"..."\u{9FFF}")
    ) != nil

    if containsChinese {
        // For Chinese words: minimum 2 characters, not a common word
        guard word.count >= 2, !isCommonWord(word) else { continue }
    } else {
        // For English words: minimum 3 characters, not a common word
        guard word.count >= 3, !isCommonWord(word.lowercased()) else { continue }
    }

    // Add to hotwords if not already present
    let wordLower = word.lowercased()
    if !settings.hotwords.contains(where: { $0.lowercased() == wordLower }) {
        settings.hotwords.append(word)
        transcriptionFeatureLogger.info(
            "Added hotword: '\(word)' (from correction '\(correction.original)' â†’ '\(correction.corrected)')"
        )
    }
}
```

**2. æ‰©å……çš„å¸¸è§è¯è¿‡æ»¤åˆ—è¡¨**ï¼ˆè¡Œ 686-718ï¼‰

```swift
private func isCommonWord(_ word: String) -> Bool {
    let commonWords: Set<String> = [
        // English common words (100+)
        "the", "and", "for", "are", "but", "not", "you", "all", "can", ...

        // Chinese common single characters
        "çš„", "æ˜¯", "åœ¨", "äº†", "å’Œ", "æœ‰", "æˆ‘", "ä»–", "å¥¹", "å®ƒ", ...

        // Chinese common 2-character words
        "æˆ‘ä»¬", "ä»–ä»¬", "ä»€ä¹ˆ", "æ€ä¹ˆ", "å¯ä»¥", "ä¸æ˜¯", "æ²¡æœ‰", ...

        // Chinese common 3-character words
        "ä¸çŸ¥é“", "ä¸ä¸€å®š", "æœ‰ä¸€ç‚¹", "æœ‰æ—¶å€™", "æ²¡å…³ç³»", ...

        // Chinese common 4+ character phrases
        "ä¸å¥½æ„æ€", "æ²¡å…³ç³»çš„", "å¯ä»¥çš„è¯", "å¦‚æœå¯ä»¥", ...
    ]
    return commonWords.contains(word)
}
```

#### ä¼˜åŒ–æ•ˆæœ

**åœºæ™¯ 1ï¼šæ··åˆè¯­è¨€ä¿®æ­£**
```
åŸæ–‡ï¼š"Anti-Gravity claude"
ä¿®æ”¹ï¼š"Antigravity Claude"

æå–è¿‡ç¨‹ï¼š
1. åˆ†è¯ï¼š["Antigravity", "Claude"]
2. é€è¯è¯„ä¼°ï¼š
   - "Antigravity" (11 å­—ç¬¦ï¼Œè‹±æ–‡) â†’ âœ… æ·»åŠ 
   - "Claude" (6 å­—ç¬¦ï¼Œè‹±æ–‡) â†’ âœ… æ·»åŠ 

æœ€ç»ˆæ·»åŠ ï¼šAntigravity, Claude
```

**åœºæ™¯ 2ï¼šä¸­æ–‡ä¸“æœ‰åè¯**
```
åŸæ–‡ï¼š"å®‰è¸ç½—æ¯”å…‹"
ä¿®æ”¹ï¼š"Anthropic"

æå–è¿‡ç¨‹ï¼š
1. åˆ†è¯ï¼š["Anthropic"]
2. è¯„ä¼°ï¼šè‹±æ–‡è¯ï¼Œ10 å­—ç¬¦ â†’ âœ… æ·»åŠ 

æœ€ç»ˆæ·»åŠ ï¼šAnthropic
```

**åœºæ™¯ 3ï¼šä¸­æ–‡å¸¸è§è¯è¿‡æ»¤**
```
åŸæ–‡ï¼š"æˆ‘åœ¨è¿™é‡Œ"
ä¿®æ”¹ï¼š"æˆ‘åœ¨è¿™é‡Œä½¿ç”¨ Claude"

æå–è¿‡ç¨‹ï¼š
1. åˆ†è¯ï¼š["æˆ‘åœ¨è¿™é‡Œä½¿ç”¨", "Claude"]
2. é€è¯è¯„ä¼°ï¼š
   - "æˆ‘åœ¨è¿™é‡Œä½¿ç”¨" (åŒ…å«ä¸­æ–‡ï¼Œä½†åŒ…å«å¸¸è§è¯"æˆ‘""åœ¨""è¿™") â†’ âŒ è·³è¿‡
   - "Claude" â†’ âœ… æ·»åŠ 

æœ€ç»ˆæ·»åŠ ï¼šClaude
```

#### æŠ€æœ¯äº®ç‚¹

1. **è‡ªåŠ¨è¯­è¨€è¯†åˆ«**ï¼šæ£€æµ‹è¯è¯­ä¸­æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦ï¼ˆUnicode èŒƒå›´ U+4E00 - U+9FFFï¼‰
2. **å·®å¼‚åŒ–è¿‡æ»¤**ï¼š
   - è‹±æ–‡è¯ï¼šâ‰¥ 3 å­—ç¬¦
   - ä¸­æ–‡è¯ï¼šâ‰¥ 2 å­—ç¬¦
3. **å…¨é¢çš„å¸¸è§è¯åº“**ï¼šè¦†ç›–ä¸­è‹±æ–‡å¸¸è§è¯æ±‡ 200+
4. **ç²¾å‡†æ—¥å¿—**ï¼šè®°å½•æ¯ä¸ªçƒ­è¯çš„æ¥æºä¿®æ­£ï¼Œä¾¿äºè°ƒè¯•

---

### åŠŸèƒ½ 10ï¼šæ¨¡å‹å¯ç”¨æ€§åˆ¤æ–­ä¼˜åŒ–

#### é—®é¢˜èƒŒæ™¯

ä¹‹å‰çš„å®ç°åœ¨æ¨¡å‹åŠ è½½æ—¶ä¼šé˜»æ­¢ç”¨æˆ·å½•éŸ³ï¼š

```swift
// æ—§ä»£ç ï¼ˆTranscriptionFeature.swiftï¼‰
func handleStartRecording(_ state: inout State) -> Effect<Action> {
    guard state.modelBootstrapState.isModelReady else {
        return .merge(
            .send(.modelMissing),
            .run { _ in soundEffect.play(.cancel) }
        )
    }
    // ... å¼€å§‹å½•éŸ³
}
```

**é—®é¢˜åœºæ™¯**ï¼š
1. ç”¨æˆ·åˆ‡æ¢æ¨¡å‹ï¼ˆå¦‚ Whisper Mediumï¼‰
2. æ¨¡å‹å¼€å§‹åŠ è½½ï¼ˆéœ€è¦ 20 ç§’ï¼‰
3. ç”¨æˆ·æŒ‰å¿«æ·é”®å½•éŸ³
4. âŒ ç³»ç»Ÿæç¤º "æ¨¡å‹ç¼ºå¤±"ï¼Œæ‹’ç»å½•éŸ³
5. å®é™…ä¸Šæ¨¡å‹æ­£åœ¨åŠ è½½ï¼Œåªæ˜¯è¿˜æ²¡å®Œæˆ

**æ—¥å¿—ç¤ºä¾‹**ï¼š
```
Preparing model download and load for openai_whisper-medium
Loading models...
Loaded models for whisper size: medium in 20.52s
Loaded WhisperKit model openai_whisper-medium
App will resign active
Model missing - activating app and switching to settings  â† é”™è¯¯æç¤º
```

#### è§£å†³æ–¹æ¡ˆï¼šç§»é™¤è¿‡æ—©çš„å¯ç”¨æ€§æ£€æŸ¥

**æ¶‰åŠæ–‡ä»¶**ï¼š`Hex/Features/Transcription/TranscriptionFeature.swift`

**æ ¸å¿ƒä¿®æ”¹**ï¼ˆè¡Œ 301-307ï¼‰ï¼š

```swift
func handleStartRecording(_ state: inout State) -> Effect<Action> {
    // Note: We don't check isModelReady here because transcription.transcribe()
    // handles model loading automatically. If there's a real model issue, it will
    // throw an error that gets handled by handleTranscriptionError.

    state.isRecording = true
    let startTime = Date()
    state.recordingStartTime = startTime

    // ... ç»§ç»­å½•éŸ³æµç¨‹
}
```

**å…³é”®ç‚¹**ï¼š

1. **å»¶è¿Ÿé”™è¯¯æ£€æŸ¥**ï¼šä¸åœ¨å½•éŸ³å¼€å§‹æ—¶æ£€æŸ¥ `isModelReady`
2. **ä¾èµ–è½¬å½•å±‚å¤„ç†**ï¼š`transcription.transcribe()` å†…éƒ¨ä¼šç­‰å¾…æ¨¡å‹åŠ è½½å®Œæˆ
3. **çœŸå®é”™è¯¯æ•è·**ï¼šå¦‚æœæ¨¡å‹çœŸçš„æœ‰é—®é¢˜ï¼ˆæ–‡ä»¶ç¼ºå¤±ã€æŸåç­‰ï¼‰ï¼Œè½¬å½•å±‚ä¼šæŠ›å‡ºé”™è¯¯ï¼Œç”± `handleTranscriptionError` å¤„ç†

#### è½¬å½•å±‚çš„æ¨¡å‹åŠ è½½é€»è¾‘

**æ–‡ä»¶**ï¼š`Hex/Clients/TranscriptionClient.swift`ï¼ˆè¡Œ 317-328ï¼‰

```swift
func transcribe(...) async throws -> String {
    let model = await resolveVariant(model)

    // Load or switch to the required model if needed.
    if whisperKit == nil || model != currentModelName {
        unloadCurrentModel()
        let startLoad = Date()

        try await downloadAndLoadModel(variant: model) { p in
            progressCallback(p)
        }

        let loadDuration = Date().timeIntervalSince(startLoad)
        transcriptionLogger.info(
            "WhisperKit ensureLoaded model=\(model) took \(String(format: "%.2f", loadDuration))s"
        )
    }

    guard let whisperKit = whisperKit else {
        throw NSError(
            domain: "TranscriptionClient",
            code: -1,
            userInfo: [NSLocalizedDescriptionKey: "Failed to initialize WhisperKit for model: \(model)"]
        )
    }

    // æ‰§è¡Œè½¬å½•
    let results = try await whisperKit.transcribe(audioPath: url.path, decodeOptions: finalOptions)
    return results.map(\.text).joined(separator: " ")
}
```

**åŠ è½½æµç¨‹**ï¼š
1. æ£€æŸ¥æ¨¡å‹æ˜¯å¦å·²åŠ è½½
2. å¦‚æœæœªåŠ è½½æˆ–æ¨¡å‹ä¸åŒ¹é…ï¼Œè°ƒç”¨ `downloadAndLoadModel`
3. ä¸‹è½½å’ŒåŠ è½½å®Œæˆåæ‰æ‰§è¡Œè½¬å½•
4. å¦‚æœå¤±è´¥ï¼ŒæŠ›å‡ºå…·ä½“é”™è¯¯

#### ä¼˜åŒ–æ•ˆæœ

**ä¿®æ”¹å‰çš„ç”¨æˆ·ä½“éªŒ**ï¼š
```
ç”¨æˆ·æ“ä½œ                ç³»ç»Ÿå“åº”
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. åˆ‡æ¢åˆ° Whisper Medium
2. æ¨¡å‹å¼€å§‹åŠ è½½...     â³ åŠ è½½ä¸­ï¼ˆ20 ç§’ï¼‰
3. ç”¨æˆ·æŒ‰å¿«æ·é”®å½•éŸ³
4.                      âŒ "æ¨¡å‹ç¼ºå¤±" é”™è¯¯æç¤º
5. ç”¨æˆ·å›°æƒ‘ï¼šæ˜æ˜åœ¨ä¸‹è½½å•Šï¼Ÿ
```

**ä¿®æ”¹åçš„ç”¨æˆ·ä½“éªŒ**ï¼š
```
ç”¨æˆ·æ“ä½œ                ç³»ç»Ÿå“åº”
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. åˆ‡æ¢åˆ° Whisper Medium
2. æ¨¡å‹å¼€å§‹åŠ è½½...     â³ åŠ è½½ä¸­ï¼ˆ20 ç§’ï¼‰
3. ç”¨æˆ·æŒ‰å¿«æ·é”®å½•éŸ³
4. å½•éŸ³å¼€å§‹            ğŸ¤ æ­£å¸¸å½•éŸ³
5. å½•éŸ³ç»“æŸ
6.                      â³ ç­‰å¾…æ¨¡å‹åŠ è½½å®Œæˆ
7.                      âœ… è½¬å½•å®Œæˆï¼Œå¼¹å‡ºç¼–è¾‘çª—å£
```

#### é”™è¯¯å¤„ç†è·¯å¾„

**çœŸå®çš„æ¨¡å‹é—®é¢˜**ï¼ˆæ–‡ä»¶æŸåã€ä¸‹è½½å¤±è´¥ç­‰ï¼‰ï¼š
```swift
// TranscriptionFeature.swift è¡Œ 399-402
do {
    let result = try await transcription.transcribe(...)
    await send(.transcriptionResult(result, capturedURL))
} catch {
    transcriptionFeatureLogger.error("Transcription failed: \(error.localizedDescription)")
    await send(.transcriptionError(error, audioURL))  // â† é”™è¯¯è¢«æ­£ç¡®æ•è·
}
```

**é”™è¯¯å±•ç¤º**ï¼ˆTranscriptionFeature.swift è¡Œ 602-616ï¼‰ï¼š
```swift
func handleTranscriptionError(
    _ state: inout State,
    error: Error,
    audioURL: URL?
) -> Effect<Action> {
    state.isTranscribing = false
    state.isPrewarming = false
    state.error = error.localizedDescription  // â† æ˜¾ç¤ºå…·ä½“é”™è¯¯ä¿¡æ¯

    if let audioURL {
        try? FileManager.default.removeItem(at: audioURL)
    }

    return .none
}
```

#### æŠ€æœ¯ä¼˜åŠ¿

1. **ç”¨æˆ·ä½“éªŒä¼˜å…ˆ**ï¼šå…è®¸åœ¨æ¨¡å‹åŠ è½½æ—¶å½•éŸ³ï¼Œå‡å°‘ç­‰å¾…æ—¶é—´
2. **é”™è¯¯å¤„ç†ä¸‹æ²‰**ï¼šåœ¨æœ€åˆé€‚çš„å±‚çº§ï¼ˆè½¬å½•å±‚ï¼‰å¤„ç†æ¨¡å‹é—®é¢˜
3. **ä¿¡æ¯æ›´å‡†ç¡®**ï¼šçœŸå®é”™è¯¯ä¿¡æ¯è€Œä¸æ˜¯ "æ¨¡å‹ç¼ºå¤±" çš„è¯¯å¯¼
4. **æ¶æ„åˆç†**ï¼šå½•éŸ³å±‚ä¸éœ€è¦å…³å¿ƒæ¨¡å‹åŠ è½½ç»†èŠ‚

---

### æ–°å¢æ–‡ä»¶ä¿®æ”¹æ¸…å•

| æ–‡ä»¶è·¯å¾„ | ä¿®æ”¹ç±»å‹ | ä¸»è¦æ”¹åŠ¨ |
|---------|---------|---------|
| `Hex/Features/Transcription/TranscriptionFeature.swift` | ä¿®æ”¹ | ç§»é™¤ isModelReady æ£€æŸ¥ |
| `Hex/Features/Transcription/TranscriptionFeature.swift` | ä¿®æ”¹ | ä¼˜åŒ–çƒ­è¯å­¦ä¹ é€»è¾‘ |
| `Hex/Features/Transcription/TranscriptionFeature.swift` | æ–°å¢ | æ·»åŠ  isCommonWord å‡½æ•° |

---

### æµ‹è¯•éªŒè¯

#### çƒ­è¯å­¦ä¹ ä¼˜åŒ–
- [x] æ··åˆä¸­è‹±æ–‡ä¿®æ­£ â†’ æ­£ç¡®æå–è‹±æ–‡è¯
- [x] ä¸­æ–‡ä¸“æœ‰åè¯ â†’ æ­£ç¡®æå–
- [x] å¸¸è§è¯è¿‡æ»¤ â†’ æ­£ç¡®è·³è¿‡
- [x] æ—¥å¿—è¾“å‡º â†’ æ¸…æ™°æ˜¾ç¤ºçƒ­è¯æ¥æº

#### æ¨¡å‹å¯ç”¨æ€§ä¼˜åŒ–
- [x] æ¨¡å‹åŠ è½½æœŸé—´å½•éŸ³ â†’ æ­£å¸¸å·¥ä½œ
- [x] æ¨¡å‹åŠ è½½å®Œæˆåè½¬å½• â†’ æ­£ç¡®æ‰§è¡Œ
- [x] çœŸå®æ¨¡å‹é”™è¯¯ â†’ æ­£ç¡®æ•è·å’Œæ˜¾ç¤º
- [x] 20 ç§’åŠ è½½æ—¶é—´ â†’ ç”¨æˆ·æ— æ„ŸçŸ¥

---

## ğŸ“Œ å®Œæ•´æ€»ç»“

è¿™ä¸ªé¡¹ç›®å®ç°äº†ä¸€ä¸ªå®Œæ•´çš„"å½•éŸ³ â†’ è½¬å½• â†’ ç¼–è¾‘ â†’ å­¦ä¹  â†’ ä¼˜åŒ–"çš„é—­ç¯ï¼š

### ç¬¬ä¸€é˜¶æ®µï¼šç¼–è¾‘åŠŸèƒ½ï¼ˆ2025å¹´ï¼‰
1. **å³æ—¶åé¦ˆ**ï¼šè½¬å½•å®Œç«‹å³ç¼–è¾‘ï¼Œä¸æ‰“æ–­å·¥ä½œæµ
2. **è‡ªåŠ¨å­¦ä¹ **ï¼šç³»ç»Ÿè®°ä½ä½ çš„ä¿®æ”¹ï¼Œè¶Šç”¨è¶Šå‡†
3. **æ‰‹åŠ¨å¹²é¢„**ï¼šå¯ä»¥æå‰æ·»åŠ ä¸“ä¸šæœ¯è¯­
4. **å†å²è¿½æº¯**ï¼šå¯ä»¥å›çœ‹å“ªäº›å†…å®¹è¢«ä¿®æ”¹è¿‡
5. **æ™ºèƒ½ç²˜è´´**ï¼šè‡ªåŠ¨æ’å…¥æ–‡æœ¬ï¼Œè‡ªåŠ¨æ¢å¤ç„¦ç‚¹å’Œå‰ªè´´æ¿

### ç¬¬äºŒé˜¶æ®µï¼šæ¨¡å‹ä¼˜åŒ–ï¼ˆ2026å¹´1æœˆï¼‰
6. **é—®é¢˜æ’æŸ¥**ï¼šå‘ç°å¹¶ç¡®è®¤ WhisperKit large-v3 çš„ promptTokens bug
7. **æ¨¡å‹æ¸…ç†**ï¼šç§»é™¤ä¸æ”¯æŒçƒ­è¯æˆ–ä¸æ”¯æŒä¸­æ–‡çš„æ¨¡å‹
8. **å¤šå¼•æ“æ”¯æŒ**ï¼šé›†æˆ Qwen3-ASRï¼Œæä¾› SOTA çº§åˆ«çš„ä¸­æ–‡å’Œå¤šè¯­è¨€æ”¯æŒ
9. **æ–¹è¨€è¯†åˆ«**ï¼šæ”¯æŒ 22 ç§ä¸­æ–‡æ–¹è¨€ï¼ˆç²¤è¯­ã€å››å·è¯ç­‰ï¼‰
10. **æ¶æ„å‡çº§**ï¼šå¼•å…¥ Apple MLX æ¡†æ¶ï¼Œæ€§èƒ½å’ŒåŠŸè€—æ›´ä¼˜

### ç¬¬ä¸‰é˜¶æ®µï¼šæ ¸å¿ƒä½“éªŒä¼˜åŒ–ï¼ˆ2026å¹´2æœˆåˆï¼‰
11. **æ™ºèƒ½çƒ­è¯å­¦ä¹ **ï¼šä¸­è‹±æ–‡åˆ†è¯ã€å¸¸è§è¯è¿‡æ»¤ã€è¯­è¨€è‡ªåŠ¨è¯†åˆ«
12. **æµç•…çš„å½•éŸ³ä½“éªŒ**ï¼šç§»é™¤è¿‡æ—©çš„æ¨¡å‹æ£€æŸ¥ï¼Œå…è®¸åŠ è½½æœŸé—´å½•éŸ³

### ç¬¬å››é˜¶æ®µï¼šæ–‡æœ¬å¯¹æ¯”ä¸çƒ­è¯ç®—æ³•ä¼˜åŒ–ï¼ˆ2026å¹´2æœˆ3æ—¥ï¼‰
13. **Myerså·®åˆ†ç®—æ³•**ï¼šå‡†ç¡®è¿½è¸ªè¯çº§åˆ«çš„ä¿®æ”¹
14. **æ™ºèƒ½åˆ†è¯ç³»ç»Ÿ**ï¼šä¸­è‹±æ–‡æ··åˆæ–‡æœ¬ç²¾ç¡®tokenization
15. **ç²¾å‡†çƒ­è¯æå–**ï¼šåªå­¦ä¹ çœŸæ­£è¢«ä¿®æ”¹çš„è¯ï¼Œä¸å†å­¦ä¹ æ•´å¥

---

## ç¬¬å››é˜¶æ®µè¯¦ç»†è¯´æ˜ï¼šæ–‡æœ¬å¯¹æ¯”ä¸çƒ­è¯ç®—æ³•ä¼˜åŒ–

### é—®é¢˜èƒŒæ™¯

**ä¹‹å‰çš„é—®é¢˜**ï¼š
ç”¨æˆ·ä¿®æ”¹äº†ä¸€ä¸ªè¯ï¼Œç³»ç»Ÿå´æŠŠæ•´å¥è¯éƒ½å­¦ä¹ äº†ï¼š

```
åŸæ–‡: "è¯·é—® ClaudeBot åœ¨è¿™é‡Œè¯„å—"
ä¿®æ”¹: "è¯·é—® clawdbot åœ¨è¿™é‡Œè¯„å—"

æœŸæœ›: å­¦ä¹  "ClaudeBot" â†’ "clawdbot"
å®é™…: æ·»åŠ æ•´å¥ "è¯·é—® clawdbot åœ¨è¿™é‡Œè¯„å—" ä½œä¸ºçƒ­è¯ âŒ
```

**æ ¹æœ¬åŸå› **ï¼š
1. **ç®€å•çš„ä½ç½®å¯¹æ¯”ç®—æ³•**ï¼šæ—§çš„diffç®—æ³•æŒ‰ç©ºæ ¼åˆ†è¯ï¼Œé€ä½ç½®æ¯”è¾ƒ
2. **ä¸­æ–‡åˆ†è¯å¤±è´¥**ï¼šä¸­æ–‡æ²¡æœ‰ç©ºæ ¼ï¼Œæ•´å¥è¢«å½“ä½œä¸€ä¸ªè¯
3. **æ— æ³•å¤„ç†æ’å…¥/åˆ é™¤**ï¼šåªèƒ½æ¯”å¯¹ç›¸åŒä½ç½®çš„è¯

---

### è§£å†³æ–¹æ¡ˆï¼šMyerså·®åˆ†ç®—æ³•

#### æ–°å¢æ–‡ä»¶ï¼šTextDiffAlgorithm.swift

**ä½ç½®**ï¼š`Hex/Features/TranscriptEditor/TextDiffAlgorithm.swift`

**æ ¸å¿ƒç®—æ³•**ï¼š

##### 1. æ™ºèƒ½åˆ†è¯ï¼ˆTokenizationï¼‰

```swift
// è¡Œ 18-66
static func tokenize(_ text: String) -> [String] {
    var tokens: [String] = []
    var currentToken = ""

    for char in text {
        let isChinese = ("\u{4E00}"..."\u{9FFF}").contains(char)
        let isWhitespace = char.isWhitespace
        let isPunctuation = char.isPunctuation

        if isChinese {
            // ä¸­æ–‡å­—ç¬¦ï¼šä½œä¸ºç‹¬ç«‹token
            if !currentToken.isEmpty {
                tokens.append(currentToken)
                currentToken = ""
            }
            tokens.append(String(char))
        } else if isWhitespace {
            // ç©ºæ ¼ï¼šåˆ·æ–°å½“å‰è¯
            if !currentToken.isEmpty {
                tokens.append(currentToken)
                currentToken = ""
            }
        } else if isPunctuation {
            // æ ‡ç‚¹ï¼šä½œä¸ºç‹¬ç«‹token
            if !currentToken.isEmpty {
                tokens.append(currentToken)
                currentToken = ""
            }
            tokens.append(String(char))
        } else {
            // å­—æ¯/æ•°å­—ï¼šç´¯ç§¯åˆ°å½“å‰è¯
            currentToken.append(char)
        }
    }

    return tokens
}
```

**ç¤ºä¾‹**ï¼š
```
è¾“å…¥: "è¯·é—®ClaudeBotåœ¨è¿™é‡Œè¯„å—ï¼Ÿ"
è¾“å‡º: ["è¯·", "é—®", "ClaudeBot", "åœ¨", "è¿™", "é‡Œ", "è¯„", "å—", "ï¼Ÿ"]
```

##### 2. Myerså·®åˆ†ç®—æ³•

è¿™æ˜¯ä¸€ä¸ªç»å…¸çš„æœ€çŸ­ç¼–è¾‘è·ç¦»ç®—æ³•ï¼Œç”¨äºæ‰¾åˆ°ä¸¤ä¸ªåºåˆ—ä¹‹é—´çš„æœ€å°å·®å¼‚ã€‚

```swift
// è¡Œ 68-102
static func diff(_ original: [String], _ edited: [String]) -> [DiffOperation] {
    let n = original.count
    let m = edited.count
    let max = n + m

    var v = [Int: Int]()
    v[1] = 0

    var trace: [[Int: Int]] = []

    // Forward search (æ‰¾åˆ°æœ€çŸ­è·¯å¾„)
    for d in 0...max {
        trace.append(v)

        for k in stride(from: -d, through: d, by: 2) {
            var x: Int

            if k == -d || (k != d && v[k - 1]! < v[k + 1]!) {
                x = v[k + 1]!
            } else {
                x = v[k - 1]! + 1
            }

            var y = x - k

            // Follow diagonal (ç›¸åŒçš„token)
            while x < n && y < m && original[x] == edited[y] {
                x += 1
                y += 1
            }

            v[k] = x

            if x >= n && y >= m {
                return backtrack(trace, original, edited)
            }
        }
    }
}
```

**è¿”å›çš„æ“ä½œç±»å‹**ï¼š
```swift
enum DiffOperation {
    case delete(index: Int, word: String)   // åˆ é™¤æ“ä½œ
    case insert(index: Int, word: String)   // æ’å…¥æ“ä½œ
    case equal(index: Int, word: String)    // ç›¸åŒtoken
}
```

##### 3. æå–ä¿®æ­£ï¼ˆExtract Correctionsï¼‰

```swift
// è¡Œ 167-201
static func extractCorrections(from operations: [DiffOperation]) -> [TextCorrection] {
    var corrections: [TextCorrection] = []
    var i = 0

    while i < operations.count {
        switch operations[i] {
        case .delete(_, let deletedWord):
            // æŸ¥æ‰¾åŒ¹é…çš„insertï¼ˆæ›¿æ¢æ“ä½œï¼‰
            if i + 1 < operations.count,
               case .insert(_, let insertedWord) = operations[i + 1] {
                let original = deletedWord.trimmingCharacters(in: .punctuationCharacters)
                let corrected = insertedWord.trimmingCharacters(in: .punctuationCharacters)

                if !original.isEmpty && !corrected.isEmpty &&
                   original.lowercased() != corrected.lowercased() {
                    corrections.append(TextCorrection(
                        original: original,
                        corrected: corrected
                    ))
                }
                i += 2  // è·³è¿‡deleteå’Œinsert
            } else {
                i += 1
            }
        case .insert, .equal:
            i += 1
        }
    }

    return corrections
}
```

##### 4. æ™ºèƒ½çƒ­è¯æå–

```swift
// è¡Œ 217-254
static func extractHotwords(
    from corrections: [TextCorrection],
    commonWords: Set<String>
) -> [String] {
    var hotwords: [String] = []

    for correction in corrections {
        let correctedText = correction.corrected.trimmingCharacters(...)

        // æ£€æµ‹æ˜¯å¦åŒ…å«ä¸­æ–‡
        let containsChinese = correctedText.rangeOfCharacter(
            from: CharacterSet(charactersIn: "\u{4E00}"..."\u{9FFF}")
        ) != nil

        if containsChinese {
            // ä¸­æ–‡ï¼šæ·»åŠ æ•´ä¸ªçŸ­è¯­ï¼ˆ2-10å­—ç¬¦ï¼Œéå¸¸è§è¯ï¼‰
            let length = correctedText.count
            if length >= 2 && length <= 10 && !commonWords.contains(correctedText) {
                hotwords.append(correctedText)
            }
        } else {
            // è‹±æ–‡ï¼šæŒ‰ç©ºæ ¼åˆ†è¯ï¼Œæå–å•è¯
            let words = correctedText.split(separator: " ").map {
                String($0).trimmingCharacters(in: .punctuationCharacters)
            }

            for word in words {
                // è·³è¿‡çŸ­è¯ï¼ˆ< 3å­—ç¬¦ï¼‰å’Œå¸¸è§è¯
                guard word.count >= 3, !commonWords.contains(word.lowercased()) else {
                    continue
                }
                hotwords.append(word)
            }
        }
    }

    return hotwords
}
```

---

### ä¿®æ”¹çš„æ–‡ä»¶

#### 1. TranscriptEditorFeature.swift

**ä¿®æ”¹å‰**ï¼ˆè¡Œ 105-128ï¼‰ï¼š
```swift
private func detectCorrections(original: String, edited: String) -> [TextCorrection] {
    guard original != edited else { return [] }

    let originalWords = original.split(separator: " ").map(String.init)
    let editedWords = edited.split(separator: " ").map(String.init)

    var corrections: [TextCorrection] = []

    // ç®€å•çš„é€è¯å¯¹æ¯”
    let minCount = min(originalWords.count, editedWords.count)
    for i in 0..<minCount {
        let orig = originalWords[i].trimmingCharacters(in: .punctuationCharacters)
        let edit = editedWords[i].trimmingCharacters(in: .punctuationCharacters)

        if orig.lowercased() != edit.lowercased() && !orig.isEmpty && !edit.isEmpty {
            corrections.append(TextCorrection(
                original: orig,
                corrected: edit
            ))
        }
    }

    return corrections
}
```

**ä¿®æ”¹å**ï¼ˆè¡Œ 105-108ï¼‰ï¼š
```swift
// æ£€æµ‹ä¿®æ”¹çš„è¯æ±‡ - ä½¿ç”¨ Myers diff ç®—æ³•è¿›è¡Œæ™ºèƒ½å¯¹æ¯”
private func detectCorrections(original: String, edited: String) -> [TextCorrection] {
    return TextDiffAlgorithm.detectCorrections(original: original, edited: edited)
}
```

#### 2. TranscriptionFeature.swift

**ä¿®æ”¹å†…å®¹**ï¼š

1. **ç®€åŒ–çƒ­è¯å­¦ä¹ é€»è¾‘**ï¼ˆè¡Œ 536-567ï¼‰ï¼š
```swift
$settings.withLock { settings in
    // 1. æ·»åŠ è¯æ±‡æ˜ å°„
    for correction in corrections {
        let exists = settings.wordRemappings.contains { remapping in
            remapping.match.lowercased() == correction.original.lowercased()
        }

        if !exists {
            let newRemapping = WordRemapping(
                match: correction.original,
                replacement: correction.corrected
            )
            settings.wordRemappings.append(newRemapping)
            transcriptionFeatureLogger.info("Auto-learned word remapping: '\(correction.original)' â†’ '\(correction.corrected)'")
        }
    }

    // 2. ä½¿ç”¨æ™ºèƒ½ç®—æ³•æå–çƒ­è¯
    let commonWords = getCommonWords()
    let hotwords = TextDiffAlgorithm.extractHotwords(
        from: corrections,
        commonWords: commonWords
    )

    for hotword in hotwords {
        let hotwordLower = hotword.lowercased()
        if !settings.hotwords.contains(where: { $0.lowercased() == hotwordLower }) {
            settings.hotwords.append(hotword)
            transcriptionFeatureLogger.info("Auto-learned hotword: '\(hotword)'")
        }
    }
}
```

2. **é‡æ„å¸¸è§è¯å‡½æ•°**ï¼ˆè¡Œ 712-744ï¼‰ï¼š
```swift
// ä» isCommonWord(_ word: String) -> Bool
// æ”¹ä¸º getCommonWords() -> Set<String>

private func getCommonWords() -> Set<String> {
    return [
        // English common words
        "the", "and", "for", ...

        // Chinese common words
        "çš„", "æ˜¯", "åœ¨", ...
    ]
}
```

---

### å®é™…æ•ˆæœå¯¹æ¯”

#### åœºæ™¯ 1ï¼šä¸­æ–‡å¥å­ä¸­çš„è‹±æ–‡è¯ä¿®æ­£

**è¾“å…¥**ï¼š
```
åŸæ–‡: "è¯·é—®ClaudeBotåœ¨è¿™é‡Œè¯„å—"
ä¿®æ”¹: "è¯·é—®clawdbotåœ¨è¿™é‡Œè¯„å—"
```

**æ—§ç®—æ³•**ï¼š
```
åˆ†è¯ç»“æœ: ["è¯·é—®ClaudeBotåœ¨è¿™é‡Œè¯„å—"]  // æ•´å¥ä½œä¸ºä¸€ä¸ªtoken
æ£€æµ‹åˆ°çš„ä¿®æ­£: []                      // æ²¡æœ‰æ£€æµ‹åˆ°ä»»ä½•ä¿®æ­£
æ·»åŠ çš„çƒ­è¯: "è¯·é—®clawdbotåœ¨è¿™é‡Œè¯„å—"   // âŒ é”™è¯¯ï¼šæ•´å¥ä½œä¸ºçƒ­è¯
```

**æ–°ç®—æ³•**ï¼š
```
åˆ†è¯ç»“æœ: ["è¯·", "é—®", "ClaudeBot", "åœ¨", "è¿™", "é‡Œ", "è¯„", "å—"]
ç¼–è¾‘å:   ["è¯·", "é—®", "clawdbot", "åœ¨", "è¿™", "é‡Œ", "è¯„", "å—"]

Diffæ“ä½œ:
  equal("è¯·")
  equal("é—®")
  delete("ClaudeBot")  â†
  insert("clawdbot")   â† é…å¯¹ä¸ºæ›¿æ¢
  equal("åœ¨")
  equal("è¿™")
  equal("é‡Œ")
  equal("è¯„")
  equal("å—")

æ£€æµ‹åˆ°çš„ä¿®æ­£: [TextCorrection(original: "ClaudeBot", corrected: "clawdbot")]
æ·»åŠ çš„è¯æ±‡æ˜ å°„: "ClaudeBot" â†’ "clawdbot"
æ·»åŠ çš„çƒ­è¯: "clawdbot"  // âœ… æ­£ç¡®ï¼šåªå­¦ä¹ è¢«ä¿®æ”¹çš„è¯
```

#### åœºæ™¯ 2ï¼šè‹±æ–‡å¥å­è¯åºå˜åŒ–

**è¾“å…¥**ï¼š
```
åŸæ–‡: "Hello world this is a test"
ä¿®æ”¹: "Hello this is a world test"
```

**æ—§ç®—æ³•**ï¼š
```
é€ä½ç½®æ¯”è¾ƒ:
  ä½ç½®0: "Hello" = "Hello" âœ“
  ä½ç½®1: "world" â‰  "this"  â† æ£€æµ‹ä¸ºä¿®æ­£ âŒ
  ä½ç½®2: "this"  â‰  "is"    â† æ£€æµ‹ä¸ºä¿®æ­£ âŒ
  ä½ç½®3: "is"    â‰  "a"     â† æ£€æµ‹ä¸ºä¿®æ­£ âŒ
  ä½ç½®4: "a"     â‰  "world" â† æ£€æµ‹ä¸ºä¿®æ­£ âŒ

é”™è¯¯ä¿®æ­£: ["world"â†’"this", "this"â†’"is", "is"â†’"a", "a"â†’"world"]
```

**æ–°ç®—æ³•**ï¼š
```
Diffæ“ä½œ:
  equal("Hello")
  delete("world")
  equal("this")
  equal("is")
  equal("a")
  insert("world")
  equal("test")

æ£€æµ‹åˆ°çš„ä¿®æ­£: []  // âœ… æ­£ç¡®ï¼šåªæ˜¯è¯åºå˜åŒ–ï¼Œæ²¡æœ‰çœŸæ­£çš„è¯æ±‡ä¿®æ­£
```

#### åœºæ™¯ 3ï¼šæ··åˆä¸­è‹±æ–‡ä¿®æ­£

**è¾“å…¥**ï¼š
```
åŸæ–‡: "æˆ‘ç”¨Anthropicçš„APIæ¥å¼€å‘"
ä¿®æ”¹: "æˆ‘ç”¨Claudeçš„APIæ¥å¼€å‘åº”ç”¨"
```

**æ–°ç®—æ³•åˆ†è¯**ï¼š
```
åŸå§‹: ["æˆ‘", "ç”¨", "Anthropic", "çš„", "API", "æ¥", "å¼€", "å‘"]
ç¼–è¾‘: ["æˆ‘", "ç”¨", "Claude", "çš„", "API", "æ¥", "å¼€", "å‘", "åº”", "ç”¨"]

Diffæ“ä½œ:
  equal("æˆ‘")
  equal("ç”¨")
  delete("Anthropic")  â†
  insert("Claude")     â† æ›¿æ¢
  equal("çš„")
  equal("API")
  equal("æ¥")
  equal("å¼€")
  equal("å‘")
  insert("åº”")         â† æ–°å¢è¯
  insert("ç”¨")         â† æ–°å¢è¯

æ£€æµ‹åˆ°çš„ä¿®æ­£: [TextCorrection(original: "Anthropic", corrected: "Claude")]
æ·»åŠ çš„è¯æ±‡æ˜ å°„: "Anthropic" â†’ "Claude"
æ·»åŠ çš„çƒ­è¯: "Claude"  // âœ… æ­£ç¡®ï¼šåªå­¦ä¹ æ›¿æ¢çš„è¯ï¼Œä¸å­¦ä¹ æ–°å¢çš„å¸¸è§è¯
```

---

### æŠ€æœ¯ä¼˜åŠ¿

#### 1. **å‡†ç¡®æ€§**
- âœ… ä¸­è‹±æ–‡æ··åˆæ–‡æœ¬æ­£ç¡®åˆ†è¯
- âœ… åªå­¦ä¹ çœŸæ­£è¢«ä¿®æ”¹çš„è¯
- âœ… æ­£ç¡®å¤„ç†æ’å…¥ã€åˆ é™¤ã€æ›¿æ¢æ“ä½œ
- âœ… å¿½ç•¥è¯åºå˜åŒ–

#### 2. **æ™ºèƒ½æ€§**
- âœ… è‡ªåŠ¨è¯†åˆ«ä¸­æ–‡å­—ç¬¦
- âœ… åŒºåˆ†å•è¯ã€æ ‡ç‚¹ã€ç©ºæ ¼
- âœ… è¿‡æ»¤å¸¸è§è¯ï¼ˆ200+è¯åº“ï¼‰
- âœ… é•¿åº¦è¿‡æ»¤ï¼ˆè‹±æ–‡â‰¥3å­—ç¬¦ï¼Œä¸­æ–‡â‰¥2å­—ç¬¦ï¼‰

#### 3. **æ€§èƒ½**
- âœ… O(ND) æ—¶é—´å¤æ‚åº¦ï¼ˆDä¸ºå·®å¼‚æ•°é‡ï¼‰
- âœ… å¯¹äºå¤§å¤šæ•°ç¼–è¾‘æ“ä½œéƒ½æ˜¯æœ€ä¼˜ç®—æ³•
- âœ… å†…å­˜å ç”¨åˆç†

#### 4. **å¯ç»´æŠ¤æ€§**
- âœ… ç®—æ³•ç‹¬ç«‹å°è£…
- âœ… æ¸…æ™°çš„å‡½æ•°èŒè´£
- âœ… æ˜“äºæµ‹è¯•å’Œè°ƒè¯•

---

### æ—¥å¿—ç¤ºä¾‹

**ä¿®æ­£å‰**ï¼ˆæ—§ç®—æ³•ï¼‰ï¼š
```
[INFO] Added Chinese hotword: 'è¯·é—®clawdbotåœ¨è¿™é‡Œè¯„å—' (from correction '...' â†’ '...')
```

**ä¿®æ­£å**ï¼ˆæ–°ç®—æ³•ï¼‰ï¼š
```
[INFO] Auto-learned word remapping: 'ClaudeBot' â†’ 'clawdbot'
[INFO] Auto-learned hotword: 'clawdbot'
```

---

### æ–‡ä»¶ä¿®æ”¹æ¸…å•

| æ–‡ä»¶è·¯å¾„ | ä¿®æ”¹ç±»å‹ | ä¸»è¦æ”¹åŠ¨ |
|---------|---------|---------|
| `Hex/Features/TranscriptEditor/TextDiffAlgorithm.swift` | æ–°å¢ | Myerså·®åˆ†ç®—æ³•ã€æ™ºèƒ½åˆ†è¯ã€çƒ­è¯æå– |
| `Hex/Features/TranscriptEditor/TranscriptEditorFeature.swift` | ä¿®æ”¹ | ä½¿ç”¨æ–°ç®—æ³•æ›¿æ¢æ—§çš„å¯¹æ¯”é€»è¾‘ |
| `Hex/Features/Transcription/TranscriptionFeature.swift` | ä¿®æ”¹ | ç®€åŒ–çƒ­è¯å­¦ä¹ é€»è¾‘ï¼Œä½¿ç”¨æ™ºèƒ½æå– |
| `Hex/Features/Transcription/TranscriptionFeature.swift` | é‡æ„ | isCommonWord â†’ getCommonWords |

---

### æŠ€æœ¯äº®ç‚¹æ€»ç»“
- âœ… å®Œæ•´çš„ TCA æ¶æ„å®ç°
- âœ… å¤šå¼•æ“æ™ºèƒ½è·¯ç”±ï¼ˆWhisperKit / Qwen3-ASRï¼‰
- âœ… çƒ­è¯åŠŸèƒ½å®Œæ•´å®ç°ï¼ˆç¼–ç ã€ä¼ é€’ã€å­¦ä¹ ã€ä¼˜åŒ–ï¼‰
- âœ… ä¼˜é›…çš„é”™è¯¯å¤„ç†å’Œé™çº§ç­–ç•¥
- âœ… å®Œå…¨æœ¬åœ°åŒ–æ¨ç†ï¼Œä¿æŠ¤éšç§
- âœ… æ™ºèƒ½çš„ä¸­è‹±æ–‡å¤„ç†
- âœ… æµç•…çš„ç”¨æˆ·ä½“éªŒè®¾è®¡
- âœ… **Myerså·®åˆ†ç®—æ³•ç²¾å‡†å¯¹æ¯”**
- âœ… **æ™ºèƒ½ä¸­è‹±æ–‡æ··åˆåˆ†è¯**
- âœ… **è¯çº§åˆ«ç²¾å‡†çƒ­è¯å­¦ä¹ **

ç”¨æˆ·ä½“éªŒæµç•…ï¼ŒæŠ€æœ¯å®ç°ç¨³å¥ï¼Œæ¨¡å‹æ”¯æŒå…¨é¢ï¼Œå­¦ä¹ æœºåˆ¶æ™ºèƒ½ï¼Œç®—æ³•å‡†ç¡®é«˜æ•ˆã€‚ğŸš€
