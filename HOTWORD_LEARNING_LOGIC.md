# 热词学习逻辑说明

## 核心原则

**从用户的修改中学习** - 用户修改了什么词，说明这个词容易识别错误，应该重点学习。

---

## 完整流程

```
录音 → 转录 → 即时编辑窗口
              ↓
        用户修改错误的词
              ↓
    Myers Diff 检测具体修改
    (日→热, palist→plist, Antigravityanthropic→Antigravity)
              ↓
        用户勾选"记住我的修改并学习"
              ↓
    根据分析模式筛选热词
              ↓
    添加到热词列表和词汇映射
```

---

## 三种分析模式详解

### 模式1: 传统算法（默认）

**步骤**：
1. 提取所有corrections的修正值
2. 应用规则过滤：
   - 中文：≥2字且非常见词
   - 英文：≥3字母且非常见词
3. 添加到热词列表

**示例**：
```
修改:
  - 日 → 热
  - palist → plist
  - Antigravityanthropic → Antigravity

传统算法筛选:
  ✗ 热 (常见词，在commonWords列表中)
  ✓ plist (≥3字母，非常见词)
  ✓ Antigravity (≥3字母，非常见词)

结果: ["plist", "Antigravity"]
```

**优点**：
- 快速（<1ms）
- 离线工作
- 可预测

**缺点**：
- 规则死板
- 可能误判（如"热"虽然常见但在特定场景下是专业词）

---

### 模式2: LLM分析

**步骤**：
1. 将corrections列表发送给LLM
2. LLM分析每个修正是否值得学习
3. 返回筛选后的热词列表

**LLM收到的信息**：
```
用户修改的词汇：
  - 日 → 热
  - palist → plist
  - Antigravityanthropic → Antigravity

任务：判断哪些修正后的词应该添加到热词列表
```

**LLM分析**：
```json
{
  "hotwords": ["plist", "Antigravity"],
  "reasoning": "plist是文件扩展名属于技术术语，Antigravity是产品名；热是日常用语不需要添加"
}
```

**优点**：
- 智能理解语义
- 可以识别特定领域术语
- 准确率高

**缺点**：
- 需要配置LLM
- 速度较慢（~500ms - 2s）
- 依赖网络（如果用云端LLM）

---

### 模式3: 混合模式

**策略**：
1. 优先使用LLM
2. LLM失败时自动降级到传统算法

**适用场景**：
- 想要智能分析但需要可靠性保障
- 网络不稳定的环境

---

## 关键设计决策

### 为什么只学习修改的词，而不是整个文本？

**原因1: 用户意图明确**
```
原文: "我用antropic的api开发应用"
修改: "我用Anthropic的API开发应用"

用户修改了: antropic→Anthropic, api→API
用户没修改: 应用

结论: 用户认为"应用"识别正确，不需要学习
```

**原因2: 避免噪音**
```
如果学习整个文本的所有专有名词:
- Anthropic ✓ (用户纠正的)
- API ✓ (用户纠正的)
- 应用 ✗ (用户没纠正，但被误判为需要学习)

问题: 学习了太多不需要的词，污染热词列表
```

**原因3: 提高精准度**
```
热词列表应该只包含:
- 经常被识别错误的词
- 用户明确纠正过的词

而不是:
- 所有出现过的专有名词
- 所有技术术语
```

---

## 实际案例对比

### 案例1: 文件名修正

**用户输入**：
```
原文: "打开info.palist文件"
修改: "打开info.plist文件"
```

**传统算法**：
```
检测到修改: palist → plist
判断: plist (≥3字母, 非常见词)
学习: ✓ plist
```

**LLM分析**：
```
LLM收到:
  - palist → plist

LLM返回:
  {"hotwords": ["plist"], "reasoning": "plist是配置文件扩展名，属于iOS开发术语"}

学习: ✓ plist
```

**结果**：两种方式都正确学习

---

### 案例2: 常见词修正

**用户输入**：
```
原文: "这个热此功能"
修改: "这个热词功能"
```

**传统算法**：
```
检测到修改: 此 → 词
判断: 词 (中文常见词，在commonWords中)
学习: ✗ 跳过
```

**LLM分析**：
```
LLM收到:
  - 此 → 词

LLM返回:
  {"hotwords": [], "reasoning": "词是常见字，不需要添加到热词列表"}

学习: ✗ 跳过
```

**结果**：两种方式都正确跳过

---

### 案例3: 品牌名修正

**用户输入**：
```
原文: "我用antropic的Claude"
修改: "我用Anthropic的Claude"
```

**传统算法**：
```
检测到修改: antropic → Anthropic
判断: Anthropic (≥3字母, 非常见词)
学习: ✓ Anthropic

注意: Claude没有被修改，不会学习
```

**LLM分析**：
```
LLM收到:
  - antropic → Anthropic

LLM返回:
  {"hotwords": ["Anthropic"], "reasoning": "Anthropic是AI公司名称"}

学习: ✓ Anthropic

注意: LLM也只学习修改的词
```

**结果**：正确学习品牌名

---

### 案例4: 复杂场景

**用户输入**：
```
原文: "我想尝试一下LLM辅助的日词提示功能"
修改: "我想尝试一下LLM辅助的热词提示功能"
```

**传统算法**：
```
检测到修改: 日 → 热
判断: 热 (中文常见词)
学习: ✗ 跳过

问题: 在"热词"这个专业术语中，"热"应该被学习
```

**LLM分析**：
```
LLM收到:
  - 日 → 热

LLM返回:
  {"hotwords": [], "reasoning": "虽然是在专业术语中，但热本身是常见字，系统会通过词汇映射自动纠正"}

学习: ✗ 跳过

说明: LLM理解这个修正不需要添加热词，因为已经添加了词汇映射
```

**结果**：
- 词汇映射：`日 → 热` ✓
- 热词：无

**这是合理的**，因为：
1. 词汇映射已经能解决问题
2. "热"作为单字太常见，不适合作为热词

---

## 词汇映射 vs 热词

### 词汇映射（Word Remapping）
```
作用: 替换规则
示例: 日 → 热
效果: 转录后自动将"日"替换为"热"
```

### 热词（Hotwords）
```
作用: 提示模型重点关注
示例: Anthropic, plist, API
效果: 转录时优先识别这些词
```

### 两者配合
```
用户修改: "日词" → "热词"

系统学习:
1. 词汇映射: 日 → 热
2. 热词: (根据规则判断)

结果:
- 下次说"日词"时，自动替换为"热词" ✓
- 不需要"热"作为热词
```

---

## 常见问题

### Q1: 为什么我修改了"热"但没有被学习？

**A**: "热"是常见词，系统认为不需要作为热词。但是：
- ✓ 词汇映射已添加：`日 → 热`
- ✓ 下次转录会自动替换

### Q2: LLM模式和传统模式有什么区别？

**A**:
- 传统：基于规则（长度、常见词列表）
- LLM：基于语义理解（理解专业术语、领域知识）

### Q3: 混合模式是怎么工作的？

**A**:
1. 先尝试LLM分析
2. 失败（网络问题、配置错误）时自动用传统算法
3. 保证总能完成学习

### Q4: 如何知道系统学习了什么？

**A**: 查看日志：
```
Auto-learned word remapping: 'palist' → 'plist'
Auto-learned hotword: 'plist'
```

---

## 推荐配置

### 日常使用
```
模式: 传统算法
原因: 快速、可靠、离线
```

### 专业领域（医疗、法律、技术）
```
模式: LLM分析
配置: Ollama + qwen2.5:7b
原因: 更准确识别专业术语
```

### 网络不稳定环境
```
模式: 混合模式
原因: LLM成功时更智能，失败时有保障
```

---

## 总结

**核心思想**：从用户的修改中学习，而不是猜测用户可能需要什么。

**优势**：
1. 精准：只学习真正需要的词
2. 高效：不浪费资源处理无关内容
3. 符合直觉：改了什么就学什么

**两种模式**：
- 传统：快速、规则清晰
- LLM：智能、理解语义

**最终目标**：让语音识别越用越准确！🎯
